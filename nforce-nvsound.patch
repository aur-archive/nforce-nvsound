diff -Naur NFORCE-Linux-x86-1.0-0310-pkg1.old/nvsound/main/Makefile.kbuild NFORCE-Linux-x86-1.0-0310-pkg1/nvsound/main/Makefile.kbuild
--- NFORCE-Linux-x86-1.0-0310-pkg1.old/nvsound/main/Makefile.kbuild	2005-10-21 20:59:44.000000000 -0500
+++ NFORCE-Linux-x86-1.0-0310-pkg1/nvsound/main/Makefile.kbuild	2008-08-14 10:13:48.000000000 -0500
@@ -48,16 +48,16 @@
 EXTRA_LDFLAGS := -d
 
 # Figure out how many args remap_page_ranges() wants or new remap call
-ifeq ($(shell sh $(src)/conftest.sh "$(CC)" "$(KERNEL_SOURCES)" "$(KERNEL_OUTPUT)" remap_pfn_range), 1)
+#ifeq ($(shell sh $(src)/conftest.sh "$(CC)" "$(KERNEL_SOURCES)" "$(KERNEL_OUTPUT)" remap_pfn_range), 1)
   EXTRA_CFLAGS += -DNV_REMAP_PFN_RANGE_PRESENT
-else
-  REMAP_PAGE_RANGE := $(shell sh $(src)/conftest.sh "$(CC)" "$(KERNEL_SOURCES)" "$(KERNEL_OUTPUT)" remap_page_range)
-
-  ifeq ($(REMAP_PAGE_RANGE),5)
-   EXTRA_CFLAGS += -DREMAP_NEW
-  endif
-
-endif
+#else
+#  REMAP_PAGE_RANGE := $(shell sh $(src)/conftest.sh "$(CC)" "$(KERNEL_SOURCES)" "$(KERNEL_OUTPUT)" remap_page_range)
+#
+#  ifeq ($(REMAP_PAGE_RANGE),5)
+#   EXTRA_CFLAGS += -DREMAP_NEW
+#  endif
+#
+#endif
 
 PATCHLEVEL ?= $(shell sh ./conftest.sh "$(CC)" "$(KERNEL_SOURCES)" "$(KERNEL_OUTPUT)" kernel_patch_level)
 ifeq ($(PATCHLEVEL), 4)
diff -Naur NFORCE-Linux-x86-1.0-0310-pkg1.old/nvsound/main/Makefile.kbuild.orig NFORCE-Linux-x86-1.0-0310-pkg1/nvsound/main/Makefile.kbuild.orig
--- NFORCE-Linux-x86-1.0-0310-pkg1.old/nvsound/main/Makefile.kbuild.orig	1969-12-31 18:00:00.000000000 -0600
+++ NFORCE-Linux-x86-1.0-0310-pkg1/nvsound/main/Makefile.kbuild.orig	2005-10-21 20:59:44.000000000 -0500
@@ -0,0 +1,116 @@
+#
+# Copyright (c) nVidia Corporation
+#
+# Makefile to build nForce main driver with kbuild
+#
+
+MODULE_NAME = nvsound
+MODULE = $(MODULE_NAME).ko
+
+SOUND_CORE_OBJ = mcpmain.o
+SOUND_GLUE_OBJS = nvalinux.o nvmixer.o nvmain.o
+
+$(MODULE_NAME)-objs := 	$(SOUND_CORE_OBJ) $(SOUND_GLUE_OBJS)
+
+KERNEL_GLUE_NAME := nvsoundif.o
+KERNEL_GLUE_OBJS :=  $(SOUND_GLUE_OBJS) $(MODULE_NAME).mod.o
+
+src ?= .
+obj ?= .
+
+obj-m := $(MODULE_NAME).o
+
+EXTRA_CFLAGS += -I$(src)
+EXTRA_CFLAGS += -Wall -Wimplicit -Wreturn-type -Wswitch -Wformat -Wchar-subscripts -Wparentheses -Wpointer-arith  -Wno-multichar  -Werror -O -MD $(DEFINES) $(INCLUDES) -Wno-cast-qual -Wno-error 
+
+ifdef SYSSRC
+  KERNEL_SOURCES := $(SYSSRC)
+  KERNEL_HEADERS := $(KERNEL_SOURCES)/include
+  MODULE_ROOT    := /lib/modules/$(shell sh $(src)/conftest.sh $(CC) $(SYSSRC) $(SYSOUT) get_uname)/kernel/sound/oss
+else
+  KERNEL_SOURCES := /lib/modules/$(shell uname -r)/build
+  KERNEL_HEADERS := $(KERNEL_SOURCES)/include
+  MODULE_ROOT    := /lib/modules/$(shell uname -r)/kernel/sound/oss
+endif
+
+ifndef SYSOUT
+  KERNEL_OUTPUT := $(KERNEL_SOURCES)
+  KBUILD_PARAMS :=
+else
+  KERNEL_OUTPUT := $(SYSOUT)
+  KBUILD_PARAMS := KBUILD_OUTPUT=$(KERNEL_OUTPUT)
+endif
+
+#
+# NVIDIA binary object file includes .common section.
+#
+
+EXTRA_LDFLAGS := -d
+
+# Figure out how many args remap_page_ranges() wants or new remap call
+ifeq ($(shell sh $(src)/conftest.sh "$(CC)" "$(KERNEL_SOURCES)" "$(KERNEL_OUTPUT)" remap_pfn_range), 1)
+  EXTRA_CFLAGS += -DNV_REMAP_PFN_RANGE_PRESENT
+else
+  REMAP_PAGE_RANGE := $(shell sh $(src)/conftest.sh "$(CC)" "$(KERNEL_SOURCES)" "$(KERNEL_OUTPUT)" remap_page_range)
+
+  ifeq ($(REMAP_PAGE_RANGE),5)
+   EXTRA_CFLAGS += -DREMAP_NEW
+  endif
+
+endif
+
+PATCHLEVEL ?= $(shell sh ./conftest.sh "$(CC)" "$(KERNEL_SOURCES)" "$(KERNEL_OUTPUT)" kernel_patch_level)
+ifeq ($(PATCHLEVEL), 4)
+  ifeq ($(shell sh ./conftest.sh "$(CC)" "$(KERNEL_SOURCES)" "$(KERNEL_OUTPUT)" change_page_attr), 1)
+    EXTRA_CFLAGS += -DNV_CHANGE_PAGE_ATTR_PRESENT
+  endif
+else
+    EXTRA_CFLAGS += -DNV_CHANGE_PAGE_ATTR_PRESENT
+endif
+
+#
+# KBUILD build parameters.
+#
+
+KBUILD_PARAMS += -C $(KERNEL_SOURCES) SUBDIRS=$(PWD) KBUILD_VERBOSE=1
+
+module: gcc-sanity-check
+	@make CC=$(CC) $(KBUILD_PARAMS) modules; \
+	if ! [ -f $(MODULE_OBJECT) ]; then \
+	  echo "$(MODULE_OBJECT) failed to build!"; \
+	  exit 1; \
+	fi
+
+$(KERNEL_GLUE_NAME): module
+	$(LD) $(EXTRA_LDFLAGS) -r -o $(KERNEL_GLUE_NAME) $(KERNEL_GLUE_OBJS)
+
+$(obj)/$(SOUND_CORE_OBJ):
+	cp $(src)/$(SOUND_CORE_OBJ) $(obj)/$(SOUND_CORE_OBJ)
+
+gcc-sanity-check:
+	@if ! sh $(src)/conftest.sh "$(CC)" "$(KERNEL_SOURCES)" "$(KERNEL_OUTPUT)" cc_sanity_check full_output $(CC); then exit 1; fi
+
+# Installation
+TARGET_KERNEL ?= $(shell uname -r)
+
+TARGETDIR = /lib/modules/$(TARGET_KERNEL)/kernel/sound/oss
+
+
+# Do fake install if not root (needed for building rpms)
+install:
+ifeq	($(wildcard $(MODULE)), $(MODULE))
+	mkdir -p $(INSTROOT)/$(TARGETDIR)
+ifeq  "$(UID)" "0"
+	install -b -m 755 -o root $(MODULE) $(INSTROOT)/$(TARGETDIR)
+	/sbin/depmod -a
+else
+	install -b -m 755 $(MODULE) $(INSTROOT)/$(TARGETDIR)
+endif # uid is root
+endif # module
+
+uninstall:
+	rm -f $(TARGETDIR)/$(MODULE)
+	/sbin/depmod -a
+
+clean:
+	rm -f *.ko *mod.* *.cmd nv*.o *~ core
diff -Naur NFORCE-Linux-x86-1.0-0310-pkg1.old/nvsound/main/conftest.sh NFORCE-Linux-x86-1.0-0310-pkg1/nvsound/main/conftest.sh
--- NFORCE-Linux-x86-1.0-0310-pkg1.old/nvsound/main/conftest.sh	2005-10-21 20:59:44.000000000 -0500
+++ NFORCE-Linux-x86-1.0-0310-pkg1/nvsound/main/conftest.sh	2008-08-14 10:13:48.000000000 -0500
@@ -422,7 +422,7 @@
           #include <asm/cacheflush.h>
         #endif
         int test_cpattr(struct page *pp, int i, pgprot_t prot) {
-            return change_page_attr(pp, i, prot);
+            return set_pages_uc(pp, i);
         }" > conftest$$.c
 
         $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
diff -Naur NFORCE-Linux-x86-1.0-0310-pkg1.old/nvsound/main/conftest.sh.orig NFORCE-Linux-x86-1.0-0310-pkg1/nvsound/main/conftest.sh.orig
--- NFORCE-Linux-x86-1.0-0310-pkg1.old/nvsound/main/conftest.sh.orig	1969-12-31 18:00:00.000000000 -0600
+++ NFORCE-Linux-x86-1.0-0310-pkg1/nvsound/main/conftest.sh.orig	2005-10-21 20:59:44.000000000 -0500
@@ -0,0 +1,483 @@
+#!/bin/bash
+
+# make sure we are in the directory containing this script
+SCRIPTDIR=`dirname $0`
+cd $SCRIPTDIR
+PATH="${PATH}:/bin:/sbin"
+
+CC="$1"
+ISYSTEM=`$CC -print-file-name=include`
+SOURCES=$2
+HEADERS=$SOURCES/include
+OUTPUT=$3
+
+CFLAGS="-D__KERNEL__ \
+-nostdinc -isystem $ISYSTEM \
+-Werror -Wimplicit-function-declaration"
+
+if [ "$OUTPUT" != "$SOURCES" ]; then
+    CFLAGS="$CFLAGS -I$OUTPUT/include2 -I$OUTPUT/include \
+-I$HEADERS -I$HEADERS/asm/mach-default"
+else
+    CFLAGS="$CFLAGS -I$HEADERS -I$HEADERS/asm/mach-default"
+fi
+
+case "$4" in
+    remap_page_range)
+        #
+        # Determine the number of arguments expected by remap_page_range.
+        #
+
+        echo "#include <linux/mm.h>
+        int do_test_remap_page_range(void) {
+           pgprot_t pgprot;
+           remap_page_range(NULL, 0L, 0L, 0L, pgprot);
+        }" > conftest$$.c
+
+        $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+        rm -f conftest$$.c
+
+        if [ -f conftest$$.o ]; then
+          echo "5"
+          rm -f conftest$$.o
+          exit 0
+        fi
+
+        echo "#include <linux/mm.h>
+        int do_test_remap_page_range(void) {
+           pgprot_t pgprot;
+           remap_page_range(0L, 0L, 0L, pgprot);
+        }" > conftest$$.c
+
+        $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+        rm -f conftest$$.c
+
+        if [ -f conftest$$.o ]; then
+          echo "4"
+          rm -f conftest$$.o
+          exit 0
+        else
+          #
+          # We couldn't determine the number of arguments expected by the
+          # remap_page_range function.
+          #
+          exit 1
+        fi
+    ;;
+
+    cc_sanity_check)
+        #
+        # Verify that the same compiler is used for the kernel and kernel
+        # module.
+        #
+        VERBOSE=$5
+        
+        if test -n "$IGNORE_CC_MISMATCH" -o -n "$SYSSRC" -o -n "$SYSINCLUDE"; then
+          #
+          # The user chose to disable the CC sanity test (which may or
+          # may not be wise) or is building the module for a kernel not
+          # currently running, which renders our test meaningless.
+          #
+          exit 0
+        fi
+
+        # usage: conftest.sh [cc_sanity_check] [full_output|just_msg] [$CC]
+
+        rm -f gcc-version-check
+        $CC gcc-version-check.c -o gcc-version-check > /dev/null 2>&1
+        if [ -f gcc-version-check ]; then
+            PROC_VERSION=`cat /proc/version`
+            MSG=`./gcc-version-check "$PROC_VERSION"`
+            RET=$?
+            rm -f gcc-version-check
+        else
+            MSG="Could not compile gcc-version-check.c"
+            RET=1
+        fi
+
+        if [ "$RET" != "0" ]; then
+            #
+            # The gcc version check failed
+            #
+            
+            if [ "$VERBOSE" = "full_output" ]; then
+                echo "";
+                echo "gcc-version-check failed:";
+                echo "";
+                echo "$MSG" | fmt -w 60
+                echo "";
+                echo "If you know what you are doing and want to override";
+                echo "the gcc version check, you can do so by setting the";
+                echo "IGNORE_CC_MISMATCH environment variable to \"1\".";
+                echo "";
+                echo "In any other case, set the CC environment variable";
+                echo "to the name of the compiler that was used to compile";
+                echo "the kernel.";
+                echo ""
+                echo -e  "*** Failed cc sanity check. Bailing out! ***";
+                echo "";
+            else
+                echo "$MSG"
+            fi
+            exit 1;
+        else
+            exit 0
+        fi
+    ;;
+
+    kernel_patch_level)
+        #
+        # Determine the kernel's major patch level; this is only done if we
+        # aren't told by KBUILD.
+        #
+
+        echo $(grep "^PATCHLEVEL =" $SOURCES/Makefile | cut -d " " -f 3)
+        exit 0
+    ;;
+
+    suser_sanity_check)
+        #
+        # Determine the caller's user id to determine if we have sufficient
+        # privileges for the requested operation.
+        #
+        if test $(id -ur) != 0; then
+            echo "";
+            echo "Please run \"make install\" as root.";
+            echo "";
+            echo -e  "*** Failed super-user sanity check. Bailing out! ***";
+            exit 1
+        else
+            exit 0
+        fi
+    ;;
+
+    rmmod_sanity_check)
+        #
+        # Make sure that any currently loaded NVIDIA kernel module can be
+        # unloaded.
+        #
+        MODULE="nvidia"
+
+        if test -n "$SYSSRC" -o -n "$SYSINCLUDE"; then
+          #
+          # Don't attempt to remove the kernel module if we're not
+          # building against the running kernel.
+          #
+          exit 0
+        fi
+
+        if lsmod | grep -wq $MODULE; then
+          rmmod $MODULE >& /dev/null
+        fi
+
+        if lsmod | grep -wq $MODULE; then
+            #
+            # The NVIDIA kernel module is still loaded, most likely because
+            # it is busy.
+            #
+            echo "";
+            echo "Unable to remove existing NVIDIA kernel module.";
+            echo "Please be sure you have exited X before attempting";
+            echo "to install the NVIDIA kernel module.";
+            echo "";
+            echo -e  "*** Failed rmmod sanity check. Bailing out! ***";
+            exit 1
+        else
+            exit 0
+        fi
+    ;;
+
+    select_makefile)
+        #
+        # Select which Makefile to use based on the version of the
+        # kernel we are building against: use the kbuild Makefile for
+        # 2.6 and newer kernels, and the old Makefile for kernels older
+        # than 2.6.
+        #
+        rm -f Makefile
+        RET=1
+        VERBOSE=$5
+        FILE="linux/version.h"
+
+        if [ -f $HEADERS/$FILE -o -f $OUTPUT/include/$FILE ]; then
+            #
+            # We are either looking at a configured kernel source
+            # tree or at headers shipped for a specific kernel.
+            # Determine the kernel version using a compile check.
+            #
+            echo "#include \"linux/version.h\"
+            int main() {
+              if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)) {
+                return 0;
+              } else {
+                return 1;
+              }
+            }" > conftest$$.c
+
+            gcc conftest$$.c -o conftest$$ -nostdinc -I $HEADERS > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$ ]; then
+                ./conftest$$ > /dev/null 2>&1
+                if [ $? = "0" ]; then
+                    ln -s Makefile.kbuild Makefile
+                else
+                    ln -s Makefile.nvidia Makefile
+                fi
+                rm -f conftest$$
+                RET=0
+            fi
+        else
+            MAKEFILE=$HEADERS/../Makefile
+            CONFIG=$HEADERS/../.config
+
+            if [ -f $MAKEFILE -a -f $CONFIG ]; then
+                #
+                # This source tree is not configured, but includes
+                # a Makefile and a .config file. If this is a 2.6
+                # kernel older than 2.6.6, that's all we require to
+                # build our module.
+                #
+                PATCHLEVEL=$(grep "^PATCHLEVEL =" $MAKEFILE | cut -d " " -f 3)
+                SUBLEVEL=$(grep "^SUBLEVEL =" $MAKEFILE | cut -d " " -f 3)
+
+                if [ $PATCHLEVEL -ge 6 -a $SUBLEVEL -le 5 ]; then
+                    ln -s Makefile.kbuild Makefile
+                    RET=0
+                fi
+            fi
+        fi
+
+        if [ "$RET" != "0" ]; then
+            echo "";
+            echo "If you are using a Linux 2.4 kernel, please make sure";
+            echo "you either have configured kernel sources matching your";
+            echo "kernel or the correct set of kernel headers installed";
+            echo "on your system.";
+            echo "";
+            echo "If you are using a Linux 2.6 kernel, please make sure";
+            echo "you have configured kernel sources matching your kernel";
+            echo "installed on your system. If you specified a separate";
+            echo "output directory using either the \"KBUILD_OUTPUT\" or";
+            echo "the \"O\" KBUILD parameter, make sure to specify this";
+            echo "directory with the SYSOUT environment variable or with";
+            echo "the appropriate nvidia-installer command line option.";
+            echo "";
+            if [ "$VERBOSE" = "full_output" ]; then
+                echo "*** Unable to determine the target kernel version. ***";
+                echo "";
+            fi
+            exit 1
+        else
+            exit 0
+        fi
+    ;;
+
+    get_uname)
+        #
+        # print UTS_RELEASE from the kernel sources that we are building
+        # against; if an error occurs, give up and just return `uname -r`
+        #
+
+        echo "#include \"linux/version.h\"
+        int main() {
+            printf(\"%s\n\", UTS_RELEASE);
+            return 0;
+        }" > conftest$$.c
+
+        CC $CFLAGS -o conftest$$ conftest$$.c > /dev/null 2>&1
+        rm -f conftest$$.c
+
+        if [ -f conftest$$ ]; then
+            ./conftest$$
+            rm -f conftest$$
+            exit 0
+        else
+            uname -r
+            exit 1
+        fi
+    ;;
+
+    rivafb_sanity_check)
+        #
+        # Check if the kernel was compiled with rivafb support. If so, then
+        # exit, since our driver no longer works with rivafb.
+        #
+        RET=1
+        VERBOSE=$5
+        FILE="linux/autoconf.h"
+
+        if [ -f $HEADERS/$FILE -o -f $OUTPUT/include/$FILE ]; then
+            #
+            # We are looking at a configured source tree; verify
+            # that its configuration doesn't include rivafb using
+            # a compile check.
+            #
+            echo "#include \"linux/autoconf.h\"
+            #ifdef CONFIG_FB_RIVA
+            #error CONFIG_FB_RIVA defined!!
+            #endif
+            " > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                rm -f conftest$$.o
+                RET=0
+            fi
+        else
+            CONFIG=$HEADERS/../.config
+            if [ -f $CONFIG ]; then
+                if [ -z "$(grep "^CONFIG_FB_RIVA=y" $CONFIG)" ]; then
+                    RET=0
+                fi
+            fi
+        fi
+
+        if [ "$RET" != "0" ]; then
+            echo "Your kernel was configured to include rivafb support!";
+            echo "";
+            echo "The rivafb driver conflicts with the NVIDIA driver, please";
+            echo "reconfigure your kernel and *disable* rivafb support, then";
+            echo "try installing the NVIDIA kernel module again.";
+            echo "";
+            if [ "$VERBOSE" = "full_output" ]; then
+                echo -e  "*** Failed rivafb sanity check. Bailing out! ***";
+                echo "";
+            fi
+            exit 1
+        else
+            exit 0
+        fi
+    ;;
+
+    rivafb_module_sanity_check)
+        #
+        # Check if the kernel was compiled with rivafb support as a module.
+        # If so, notify the user that the two are not compatible. Don't
+        # fail in this case, as many distros are likely to include this as
+        # a module.
+        #
+        RET=1
+        VERBOSE=$4
+        FILE="linux/autoconf.h"
+
+        if [ -f $HEADERS/$FILE -o -f $OUTPUT/include/$FILE ]; then
+            #
+            # We are looking at a configured source tree; verify
+            # that its configuration doesn't include rivafb using
+            # a compile check.
+            #
+            echo "#include \"linux/autoconf.h\"
+            #ifdef CONFIG_FB_RIVA_MODULE
+            #error CONFIG_FB_RIVA_MODULE defined!!
+            #endif
+            " > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                rm -f conftest$$.o
+                RET=0
+            fi
+        else
+            CONFIG=$HEADERS/../.config
+            if [ -f $CONFIG ]; then
+                if [ -z "$(grep "^CONFIG_FB_RIVA=m" $CONFIG)" ]; then
+                    RET=0
+                fi
+            fi
+        fi
+
+        if [ "$RET" != "0" ]; then
+            echo "";
+            echo "Your kernel was configured to include rivafb support as";
+            echo "a loadable kernel module.";
+            echo "";
+            echo "The rivafb driver conflicts with the NVIDIA driver; the";
+            echo "NVIDIA kernel module will still be built and installed,";
+            echo "but be aware that the NVIDIA driver will not be able to";
+            echo "function properly if the rivafb module is loaded!";
+            echo "";
+            if [ "$VERBOSE" = "full_output" ]; then
+                echo -en "*** Failed rivafb module sanity check, but ";
+                echo -e  "continuing! ***";
+                echo "";
+            fi
+        fi
+
+        exit 0
+    ;;
+
+    change_page_attr)
+        #
+        # Determine if change_page_attr() is present
+        #
+        
+        echo "#include <linux/version.h>
+        #include <linux/mm.h>
+        #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+          #include <asm/cacheflush.h>
+        #endif
+        int test_cpattr(struct page *pp, int i, pgprot_t prot) {
+            return change_page_attr(pp, i, prot);
+        }" > conftest$$.c
+
+        $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+        rm -f conftest$$.c
+
+        if [ -f conftest$$.o ]; then
+            rm -f conftest$$.o
+            echo 1
+        else
+            echo 0
+        fi
+    ;;
+
+    class_simple_create)
+        #
+        # Determine if class_simple_create() is present.
+        #
+
+        echo "#include <linux/device.h>
+        struct class_simple*
+        test_class_create(struct module *owner, char *name) {
+            return class_simple_create(owner, name);
+        }" > conftest$$.c
+
+        $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+        rm -f conftest$$.c
+
+        if [ -f conftest$$.o ]; then
+            rm -f conftest$$.o
+            echo 1
+        else
+            echo 0
+        fi
+    ;;
+
+    remap_pfn_range)
+        #
+        # Determine if remap_page_range() is present.
+        #
+
+        echo "#include <linux/mm.h>
+        int nv_remap_pfn_range(void) {
+           pgprot_t pgprot = __pgprot(0);
+           remap_pfn_range(NULL, 0L, 0L, 0L, pgprot);
+        }" > conftest$$.c
+
+        $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+        rm -f conftest$$.c
+
+        if [ -f conftest$$.o ]; then
+          rm -f conftest$$.o
+	  echo 1
+	else
+          echo 0
+        fi
+   ;;
+	
+esac
diff -Naur NFORCE-Linux-x86-1.0-0310-pkg1.old/nvsound/main/nvaioctl.h NFORCE-Linux-x86-1.0-0310-pkg1/nvsound/main/nvaioctl.h
--- NFORCE-Linux-x86-1.0-0310-pkg1.old/nvsound/main/nvaioctl.h	2005-10-21 20:59:44.000000000 -0500
+++ NFORCE-Linux-x86-1.0-0310-pkg1/nvsound/main/nvaioctl.h	2008-08-14 10:13:48.000000000 -0500
@@ -215,7 +215,7 @@
     CODEC_CAPS
 };
 
-enum device_type{
+enum dev_type{
     APU_DEVICE = 1,
     VAPU_DEVICE,
     ACI_DEVICE
diff -Naur NFORCE-Linux-x86-1.0-0310-pkg1.old/nvsound/main/nvaioctl.h.orig NFORCE-Linux-x86-1.0-0310-pkg1/nvsound/main/nvaioctl.h.orig
--- NFORCE-Linux-x86-1.0-0310-pkg1.old/nvsound/main/nvaioctl.h.orig	1969-12-31 18:00:00.000000000 -0600
+++ NFORCE-Linux-x86-1.0-0310-pkg1/nvsound/main/nvaioctl.h.orig	2005-10-21 20:59:44.000000000 -0500
@@ -0,0 +1,267 @@
+////////////////////////////////////////////////////////////////////////
+//
+//  nvaioctl.h
+//
+//  Descripion  - Header file used for the common structures for the
+//  ioctls used for apps and driver
+//
+//  Copyright (c) 2004-2005 NVIDIA Corporation
+//
+////////////////////////////////////////////////////////////////////////
+
+#ifndef _NVA_IOCTL_H_
+#define _NVA_IOCTL_H_
+
+
+//*****************************************************************************
+// Mixer Nodes
+//*****************************************************************************
+// These are the mixer topology nodes.
+//
+typedef enum
+{
+    MXR_NODE_PCBEEP_VOLUME = 0,
+    MXR_NODE_PCBEEP_MUTE,   //1
+
+    MXR_NODE_PHONE_VOLUME,  //2
+    MXR_NODE_PHONE_MUTE,    //3
+
+    MXR_NODE_MIC_BOOST,     //4
+    MXR_NODE_MIC_SELECT,    //5
+    MXR_NODE_MIC_VOLUME,    //6 
+    MXR_NODE_MIC_MUTE,      //7
+
+    MXR_NODE_LINEIN_VOLUME, //8
+    MXR_NODE_LINEIN_MUTE,   //9
+
+    MXR_NODE_CD_VOLUME,     //10
+    MXR_NODE_CD_MUTE,       //11
+
+    MXR_NODE_VIDEO_VOLUME,  //12
+    MXR_NODE_VIDEO_MUTE,    //13
+
+    MXR_NODE_AUX_VOLUME,    //14
+    MXR_NODE_AUX_MUTE,      //15
+
+    RESERVED_16,            //16
+    RESERVED_17,            //17
+
+    RESERVED_18,            //18
+    MXR_NODE_CONVERT_LINEIN_REAR,       //19
+    MXR_NODE_CONVERT_MIC_CENTERLFE,     //20
+    MXR_NODE_SWAP_CENTERLFE,            //21
+    MXR_NODE_MASTER_VOLUME,             //22
+    MXR_NODE_MASTER_MUTE,               //23
+
+
+    MXR_NODE_WAVEIN_MIC_VOLUME,         //24
+    MXR_NODE_WAVEIN_CD_VOLUME,          //25
+    MXR_NODE_WAVEIN_VIDEO_VOLUME,       //26
+    MXR_NODE_WAVEIN_AUX_VOLUME,         //27
+    MXR_NODE_WAVEIN_LINEIN_VOLUME,      //28
+    MXR_NODE_WAVEIN_STEREO_MIX_VOLUME,  //29
+    MXR_NODE_WAVEIN_MONO_MIX_VOLUME,    //30
+    MXR_NODE_WAVEIN_PHONE_VOLUME,       //31
+    MXR_NODE_WAVEIN_SPDIFIN_VOLUME,     //32
+    MXR_NODE_WAVEIN_SELECT,             //33
+
+
+    RESERVED_34,                        //34
+    MXR_NODE_LINEOUT_VOLUME,            //35
+    MXR_NODE_LINEOUT_MUTE,              //36
+
+
+    RESERVED_37,                        //37
+    MXR_NODE_HEADPHONE_VOLUME,          //38
+    MXR_NODE_HEADPHONE_MUTE,            //39
+
+    MXR_NODE_SPDIF,                     //40
+    RESERVED_41,                        //41
+    MXR_NODE_SPDIF_VOLUME,              //42
+    MXR_NODE_SPDIF_MUTE,                //43
+
+    MXR_NODE_DIGITIZED_INPUT_SELECT,    //44    
+    MXR_NODE_DIGITIZED_INPUT_VOLUME,    //45
+    MXR_NODE_DIGITIZED_INPUT_MUTE,      //46
+    MXR_NODE_DIGITIZED_INPUT_FX,        //47
+
+
+    MXR_NODE_MONOOUT_MONO_MIX_VOLUME,   //48
+    MXR_NODE_MONOOUT_MIC_VOLUME,        //49
+    MXR_NODE_MONOOUT_SELECT,            //50
+
+
+    MXR_NODE_MICIN_VOLUME,              //51
+    MXR_NODE_MICIN_MUTE,                //52
+
+    MXR_NODE_FRONT_VOLUME,              //53
+    MXR_NODE_FRONT_MUTE,                //54
+    MXR_NODE_SURROUND_VOLUME,           //55
+    MXR_NODE_SURROUND_MUTE,             //56
+    MXR_NODE_CENTER_VOLUME,             //57
+    MXR_NODE_CENTER_MUTE,               //58
+    MXR_NODE_LFE_VOLUME,                //59
+    MXR_NODE_LFE_MUTE,                  //60
+    MXR_NODE_BASS,                      //61
+    MXR_NODE_TREBLE,                    //62
+
+    MXR_NODE_3D_ENVIRONMENT_VOLUME,     //63
+    MXR_NODE_3D_ENVIRONMENT_MUTE,       //64
+
+    MXR_NODE_INVALID                    //65
+
+} MXR_NODE, *PMXR_NODE;
+
+#define FIRST_MXR_NODE    MXR_NODE_PCBEEP_VOLUME
+#define LAST_MXR_NODE     MXR_NODE_MICIN_MUTE
+#define NUM_MXR_NODES     MXR_NODE_INVALID
+
+
+enum Premix_regs{
+    PREMIX_LEFT=0,
+    PREMIX_RIGHT,
+    PREMIX_CENTER,
+    PREMIX_SUB,
+    PREMIX_RLEFT,
+    PREMIX_RRIGHT,
+    PREMIX_LEFT_SURR,
+    PREMIX_RIGHT_SURR
+};
+
+typedef struct _nva_ioctl{
+     void*  pindata;
+     void*  poutdata;
+     char   name[20];
+     unsigned int cmd;
+     unsigned int subcmd;
+     unsigned int indata[4];
+     unsigned int outdata[4];
+     float pfoutdata;
+     unsigned int inlength;
+     unsigned int outlength;        
+}NVA_IOCTL, *PNVA_IOCTL;
+
+
+#define NV_IOC_MAGIC 'n'
+#define NV_IOCRESET   _IO(NV_IOC_MAGIC, 0)
+
+#define NV_AC97CODEC_READ  _IOR(NV_IOC_MAGIC,1,NVA_IOCTL)
+#define NV_AC97CODEC_WRITE _IOW(NV_IOC_MAGIC,2,NVA_IOCTL)
+#define NV_AC97CON_READ    _IOR(NV_IOC_MAGIC,3,NVA_IOCTL)
+#define NV_AC97CON_WRITE   _IOW(NV_IOC_MAGIC,4,NVA_IOCTL)
+#define NV_SET_SPKRSELECT  _IOW(NV_IOC_MAGIC,5,NVA_IOCTL)
+#define NV_GET_SPKRSELECT  _IOR(NV_IOC_MAGIC,6,NVA_IOCTL)
+#define NV_SET_ANALOGOUT   _IOW(NV_IOC_MAGIC,7,NVA_IOCTL)
+#define NV_GET_ANALOGOUT   _IOR(NV_IOC_MAGIC,8,NVA_IOCTL)
+#define NV_SET_DIGITALOUT  _IOW(NV_IOC_MAGIC,9,NVA_IOCTL)
+#define NV_GET_DIGITALOUT  _IOR(NV_IOC_MAGIC,10,NVA_IOCTL)
+#define NV_SET_ENCODING    _IOW(NV_IOC_MAGIC,11,NVA_IOCTL)
+#define NV_GET_ENCODING    _IOR(NV_IOC_MAGIC,12,NVA_IOCTL)
+#define NV_SET_PREMIXVOL   _IOW(NV_IOC_MAGIC,13,NVA_IOCTL)
+#define NV_GET_PREMIXVOL   _IOR(NV_IOC_MAGIC,14,NVA_IOCTL)
+#define NV_GET_INFO        _IOR(NV_IOC_MAGIC,15,NVA_IOCTL)
+#define NV_SET_MIXERMUTE   _IOW(NV_IOC_MAGIC,16,NVA_IOCTL)
+#define NV_GET_MIXERMUTE   _IOR(NV_IOC_MAGIC,17,NVA_IOCTL)
+#define NV_GET_ONOFF       _IOR(NV_IOC_MAGIC,18,NVA_IOCTL)
+#define NV_SET_ONOFF       _IOW(NV_IOC_MAGIC,19,NVA_IOCTL)
+#define NV_GET_EQPRESET    _IOR(NV_IOC_MAGIC,20,NVA_IOCTL)
+#define NV_SET_EQPRESET    _IOW(NV_IOC_MAGIC,21,NVA_IOCTL)
+#define NV_GET_EQINFO      _IOR(NV_IOC_MAGIC,22,NVA_IOCTL)
+#define NV_GET_EQDATA      _IOR(NV_IOC_MAGIC,23,NVA_IOCTL)
+#define NV_SET_EQDATA      _IOW(NV_IOC_MAGIC,24,NVA_IOCTL)
+#define NV_SET_AMPLIFIER   _IOW(NV_IOC_MAGIC,25,NVA_IOCTL)
+
+#define NV_IOC_HARDRESET   _IO(NV_IOC_MAGIC, 26)
+
+#define NV_IOC_MAXNR  NV_IOC_HARDRESET
+
+typedef enum {
+    NV_SPKR_HEAD = 0,
+    NV_SPKR_STEREO,
+    NV_SPKR_QUAD,
+    NV_SPKR_5POINT1,
+    NV_SPKR_7POINT1
+}NV_SPKR_SEETINGS;
+
+typedef enum {
+    ANALOG_OUT = 0,
+    DIGITAL_OUT,
+    MIC_BOOST,
+    SWAP_LINEIN,
+    SWAP_MICIN,
+    SWAP_CENTERLFE,
+	ALTER_MIC,
+	GLOBAL_EQ
+}ON_OFFPARAMS;
+
+enum encoding_options{
+    EN_NONE = 0,
+    EN_CLONE,
+    EN_DELAY,
+    EN_TIME,
+    EN_PRESET,
+    EN_LFECROSSOVER,
+    EN_LFECROSSOVERRANGE
+};
+
+enum info_options{
+    PRODUCT_NAME = 0,
+    HW_MODEL,
+    HW_REV,
+    DRIVER_VERSION,
+    KERNEL_VERSION,
+    CODEC_NAME,
+    CODEC_MODEL,
+    CODEC_CAPS
+};
+
+enum device_type{
+    APU_DEVICE = 1,
+    VAPU_DEVICE,
+    ACI_DEVICE
+};
+
+//
+// Defined Presets for Global EQ
+// Use Custom to set user defined Values
+//
+typedef enum
+{
+    GBEQ_FLAT = 0,
+    GBEQ_CLASSICAL,
+    GBEQ_CLUB,
+    GBEQ_DANCE,
+    GBEQ_FULLBASS,
+    GBEQ_FULLBASSANDTREBLE,
+    GBEQ_FULLTREBLE,
+    GBEQ_HEADPHONES,
+    GBEQ_LARGEHALL,
+    GBEQ_LIVE,
+    GBEQ_OLDTIMERADIO,
+    GBEQ_PARTY,
+    GBEQ_POP,
+    GBEQ_REGGAE,
+    GBEQ_ROCK,
+    GBEQ_SOFT,
+    GBEQ_SOFTROCK,
+    GBEQ_TECHNO,
+    GBEQ_CUSTOM             // This on is always last
+} GBEQ_PRESETS, *PGBEQ_PRESETS;
+
+//
+// Possible Frequency Range allowed for EQ bands
+//
+
+enum{
+	GBEQ_FREQ63 = 0,
+	GBEQ_FREQ125,
+	GBEQ_FREQ250,
+	GBEQ_FREQ500,
+	GBEQ_FREQ1K,
+	GBEQ_FREQ2K,
+	GBEQ_FREQ4K,
+	GBEQ_FREQ8K,
+	GBEQ_FREQ16K
+};
+
+#endif
diff -Naur NFORCE-Linux-x86-1.0-0310-pkg1.old/nvsound/main/nvalinux.c NFORCE-Linux-x86-1.0-0310-pkg1/nvsound/main/nvalinux.c
--- NFORCE-Linux-x86-1.0-0310-pkg1.old/nvsound/main/nvalinux.c	2005-10-21 20:59:44.000000000 -0500
+++ NFORCE-Linux-x86-1.0-0310-pkg1/nvsound/main/nvalinux.c	2008-08-14 10:13:48.000000000 -0500
@@ -60,10 +60,14 @@
 #define SET_FPU_INUSE(x) ((x->flags) |= PF_USEDFPU)
 #define CLEAR_FPU_INUSE(x) ((x->flags) &= ~PF_USEDFPU)
 #define IS_FPU_INUSE(x) ((x->flags) & PF_USEDFPU)
-#else
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
 #define SET_FPU_INUSE(x) ((x->thread_info->status) |= TS_USEDFPU)
 #define CLEAR_FPU_INUSE(x) ((x->thread_info->status) &= ~TS_USEDFPU)
 #define IS_FPU_INUSE(x) ((x->thread_info->status) & TS_USEDFPU)
+#else
+#define SET_FPU_INUSE(x) ((task_thread_info(x)->status) |= TS_USEDFPU)
+#define CLEAR_FPU_INUSE(x) ((task_thread_info(x)->status) &= ~TS_USEDFPU)
+#define IS_FPU_INUSE(x) ((task_thread_info(x)->status) & TS_USEDFPU)
 #endif
 
 #include "nvavm.h"
@@ -182,11 +186,11 @@
         if ( cpu_has_fxsr ) {
 			__asm__ __volatile__( "fxsave %0\n"
 								"fnclex"
-								:"=m"(currenttask->thread.i387.fxsave) );
+								:"=m"(currenttask->thread.xstate->fxsave) );
 		} else {
 			__asm__ __volatile__( "fnsave %0\n"
 							"fwait"
-							:"=m"(currenttask->thread.i387.fsave) );
+							:"=m"(currenttask->thread.xstate->fsave) );
 		}
 		CLEAR_FPU_INUSE(currenttask);
     }
diff -Naur NFORCE-Linux-x86-1.0-0310-pkg1.old/nvsound/main/nvalinux.c.orig NFORCE-Linux-x86-1.0-0310-pkg1/nvsound/main/nvalinux.c.orig
--- NFORCE-Linux-x86-1.0-0310-pkg1.old/nvsound/main/nvalinux.c.orig	1969-12-31 18:00:00.000000000 -0600
+++ NFORCE-Linux-x86-1.0-0310-pkg1/nvsound/main/nvalinux.c.orig	2005-10-21 20:59:44.000000000 -0500
@@ -0,0 +1,1358 @@
+/* 
+ *
+ * Copyright 2003-2004 by NVIDIA Corporation.  All rights reserved.  All
+ * information contained herein is proprietary and confidential to NVIDIA
+ * Corporation.  Any use, reproduction, or disclosure without the written
+ * permission of NVIDIA Corporation is prohibited.
+ * 
+ */
+
+/*
+* nvalinux.c
+*
+* Implementation of functions calling kenrel functions
+*
+*/
+
+#define __NO_VERSION_
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <asm/io.h>
+#include <linux/string.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <asm/uaccess.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#include <linux/wrapper.h>
+#endif
+
+#include <linux/highmem.h>
+#include <asm/pgtable.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#define NV_MAY_SLEEP() (!in_interrupt())
+#else
+#define NV_MAY_SLEEP() (!in_interrupt() && !in_atomic())
+#endif
+
+#if defined (__i386__) || defined (__x86_64__)
+#include <asm/i387.h>
+#endif
+#include "nvalinux.h"
+
+#if !defined ASSERT
+#define ASSERT(expr) do { \
+    if(!(expr)){\
+    printk("Nvsound: Assertion [%s] failed %s:%s(line=%d)\n",\
+        #expr,__FILE__,__FUNCTION__,__LINE__);\
+    }}while(0)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#define SET_FPU_INUSE(x) ((x->flags) |= PF_USEDFPU)
+#define CLEAR_FPU_INUSE(x) ((x->flags) &= ~PF_USEDFPU)
+#define IS_FPU_INUSE(x) ((x->flags) & PF_USEDFPU)
+#else
+#define SET_FPU_INUSE(x) ((x->thread_info->status) |= TS_USEDFPU)
+#define CLEAR_FPU_INUSE(x) ((x->thread_info->status) &= ~TS_USEDFPU)
+#define IS_FPU_INUSE(x) ((x->thread_info->status) & TS_USEDFPU)
+#endif
+
+#include "nvavm.h"
+
+static struct pci_dev * pAci_device;
+static struct pci_dev * pApu_device;
+static DEVICE_RESOURCES apu_res;
+
+static spinlock_t global_spinlock = SPIN_LOCK_UNLOCKED;
+static unsigned long global_flags       = 0;
+
+//
+// Array used to save the FP reg values for local use
+//
+#define NV_MAX_FPLOOP  5
+#if defined (__i386__)
+static struct i387_fsave_struct  nvfnSave[NV_MAX_FPLOOP];
+#else
+static struct i387_fxsave_struct  nvfxSave[NV_MAX_FPLOOP];
+#endif
+
+static int nvfpused[NV_MAX_FPLOOP] = {0};
+
+static VOID * ApuLinearAddress = 0;
+
+static unsigned int setvapu = 0;
+
+#ifdef __cplusplus
+extern "C"  {
+#endif
+
+#if defined (__i386__)
+//*****************************************************************************
+// _get_phys_address
+// virtual address to physical page address
+//*****************************************************************************
+
+static unsigned long
+_get_phys_address(
+    unsigned long address,
+    int kern
+)
+{
+    struct mm_struct *mm;
+    pgd_t *pgd = NULL;
+    pmd_t *pmd = NULL;
+    pte_t *pte = NULL;
+    unsigned long retval;
+
+    mm = (kern) ? &init_mm : current->mm;
+    spin_lock(&mm->page_table_lock);
+
+    pgd = NV_PGD_OFFSET(address, kern, mm);
+    if (!NV_PGD_PRESENT(pgd))
+        goto failed;
+
+    pmd = NV_PMD_OFFSET(address, pgd);
+    if (!NV_PMD_PRESENT(pmd))
+        goto failed;
+
+    pte = NV_PTE_OFFSET(address, pmd);
+    if (!NV_PTE_PRESENT(pte))
+        goto failed;
+
+    retval = ((NV_PTE_VALUE(pte) & PAGE_MASK) | NV_MASK_OFFSET(address));
+
+    spin_unlock(&mm->page_table_lock);
+    return retval;
+
+failed:
+    spin_unlock(&mm->page_table_lock);
+    return 0;
+}
+
+//*****************************************************************************
+// nv_get_kern_phys_address
+//*****************************************************************************
+static unsigned long nv_get_kern_phys_address(
+    unsigned long address
+)
+{
+    // make sure this address is a kernel pointer
+#if !defined(CONFIG_X86_4G)
+    if (address < PAGE_OFFSET)
+    {
+        printk("user address passed to get_kern_phys_address: 0x%lx\n",
+            address);
+        return 0;
+    }
+#endif
+
+    /* direct-mapped kernel address */
+    if ((address > PAGE_OFFSET) && (address < VMALLOC_START))
+        return __pa(address);
+
+    return _get_phys_address(address, 1);
+}
+#endif
+//*****************************************************************************
+// AosFpuSave
+//*****************************************************************************
+VOID NV_API_CALL  AosFpuSave(int *pTag)
+{   
+	int count = 0;	
+	// get the current process
+	struct task_struct *currenttask = current;
+
+#if defined (__i386__)
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,68)
+	preempt_disable();
+#endif
+
+	// check for FPU used flags
+	if (IS_FPU_INUSE(currenttask)) {
+        if ( cpu_has_fxsr ) {
+			__asm__ __volatile__( "fxsave %0\n"
+								"fnclex"
+								:"=m"(currenttask->thread.i387.fxsave) );
+		} else {
+			__asm__ __volatile__( "fnsave %0\n"
+							"fwait"
+							:"=m"(currenttask->thread.i387.fsave) );
+		}
+		CLEAR_FPU_INUSE(currenttask);
+    }
+	else {
+		clts();
+	}
+	
+#else
+    kernel_fpu_begin();
+#endif
+	
+	while(count < NV_MAX_FPLOOP) {
+		if(nvfpused[count] == 0) break;
+		count = count + 1;
+	}
+	nvfpused[count] = 1;
+#if defined (__i386__)
+	asm volatile("fnsave %0;fnclex; fwait" : "=m"(nvfnSave[count]));
+#else
+	asm volatile("fxsave %0;fnclex; fwait" : "=m"(nvfxSave[count]));
+#endif
+	*pTag = count;
+
+	if(setvapu) {
+		SET_FPU_INUSE(currenttask);
+	}
+}
+
+
+//*****************************************************************************
+// AosFpuRestore
+//*****************************************************************************
+VOID NV_API_CALL  AosFpuRestore(int pTag)
+{
+	struct task_struct *currenttask = current;
+	if(pTag > -1){
+#if defined (__i386__)
+		asm volatile("frstor %0" :  : "m" (nvfnSave[pTag]));
+#else
+		asm volatile("fxrstor %0" :  : "m" (nvfxSave[pTag]));
+#endif
+		nvfpused[pTag] = 0;
+
+		if(setvapu && (pTag == 0)) {
+			if (IS_FPU_INUSE(currenttask)) {
+				CLEAR_FPU_INUSE(currenttask);
+			}
+		}
+	}
+    kernel_fpu_end();
+}
+
+//*****************************************************************************
+// AosMemoryAlloc
+//*****************************************************************************
+VOID * NV_API_CALL AosMemoryAlloc
+(
+ IN  PAOS_CONTEXT pAosContext,
+ IN  ULONG Size
+)
+{   
+    void * pAddress = 0;
+    pAddress = kmalloc( (size_t)Size, GFP_KERNEL);
+    if(pAddress){
+        memset(pAddress,'\0',Size);
+    }
+    return (pAddress);
+}
+
+//*****************************************************************************
+// AosMemoryAllocVM
+//*****************************************************************************
+VOID * NV_API_CALL AosMemoryAllocVM
+(
+ IN  PAOS_CONTEXT pAosContext,
+ IN  ULONG Size
+)
+{   
+    void * pAddress = 0;
+    if(NV_MAY_SLEEP()) {
+      pAddress = vmalloc_32(Size);
+    }
+    if(pAddress){
+        memset(pAddress,'\0',Size);
+    }
+    return (pAddress);
+}
+
+//*****************************************************************************
+// AosMemoryAllocAtomic
+//*****************************************************************************
+VOID * NV_API_CALL AosMemoryAllocAtomic
+(
+ IN  PAOS_CONTEXT pAosContext,
+ IN  ULONG Size
+)
+{
+    void * pAddress = 0;
+    if(!NV_MAY_SLEEP()) {
+        pAddress = kmalloc( (size_t)Size, GFP_ATOMIC);
+    }
+    if(pAddress){
+        memset(pAddress,'\0',Size);
+    }
+    return (pAddress);
+}
+
+//*****************************************************************************
+// AosMemoryFree
+//*****************************************************************************
+VOID NV_API_CALL AosMemoryFree
+(
+    IN  PAOS_CONTEXT pAosContext,
+    IN  VOID * pAddr
+)
+{
+    unsigned long vaddr = (unsigned long) pAddr;
+    if( vaddr >= VMALLOC_START && vaddr < VMALLOC_END) 
+      return vfree(pAddr);
+    return kfree((const void*) pAddr);
+}
+
+//*****************************************************************************
+// AosMemoryZero
+//*****************************************************************************
+// Zero a section of memory.
+//
+VOID NV_API_CALL  AosMemoryZero
+(
+    IN  PAOS_CONTEXT pAosContext,
+    IN  VOID * pData,
+    IN  ULONG Size
+)
+{
+    memset(pData,'\0',Size);
+}
+
+//*****************************************************************************
+// AosMemoryCopy
+//*****************************************************************************
+// Copy a section of memory to another section of memory.
+//
+VOID NV_API_CALL AosMemoryCopy
+(
+    IN  PAOS_CONTEXT pAosContext,
+    IN  VOID * pDestination,
+    IN  VOID * pSource,
+    IN  ULONG Size
+)
+{
+    memcpy(pDestination,pSource,Size);
+}
+
+//*****************************************************************************
+// AosMemoryCompare
+//*****************************************************************************
+// Compares one memory area to another based on size.
+//
+BOOL NV_API_CALL AosMemoryCompare
+(
+    IN  PAOS_CONTEXT pAosContext,
+    IN  VOID * pSource1,
+    IN  VOID * pSource2,
+    IN  ULONG Length
+)
+{
+    int retValue = memcmp(pSource1,pSource2,Length);
+    // To make it compatible with windows 
+    return ( (retValue)? 0 : 1);
+    
+}
+
+//*****************************************************************************
+// AosMemorySet
+//*****************************************************************************
+// Set thememory area with a single value
+//
+VOID NV_API_CALL  AosMemorySet
+(
+    IN  PAOS_CONTEXT pAosContext,
+    IN  VOID * pDestination,
+    IN  VOID * pData,
+    IN  ULONG Length
+)    
+{
+    memset(pDestination,(int)(LONG_PTR)pData,Length);
+}
+
+//*****************************************************************************
+// AosAtomicDecrement
+//*****************************************************************************
+// Atomically decrements the value at the specified address and returns the
+// new value.
+//
+LONG NV_API_CALL AosAtomicDecrement
+(
+    IN  PAOS_CONTEXT pAosContext,
+    IN  VOID* pAddr
+)
+{
+    atomic_dec((atomic_t *) pAddr);
+    return atomic_read((atomic_t *) pAddr);
+}
+
+//*****************************************************************************
+// AosAtomicIncrement
+//*****************************************************************************
+// Atomically increments the value at the specified address and returns the
+// new value.
+//
+LONG NV_API_CALL AosAtomicIncrement
+(
+    IN  PAOS_CONTEXT pAosContext,
+    IN  VOID* pAddr
+)
+{
+    atomic_inc((atomic_t *) pAddr);
+    return atomic_read((atomic_t *)pAddr);
+}
+
+//*****************************************************************************
+// AosAtomicSet
+//*****************************************************************************
+// Atomically sets the value at the specified address and returns the old
+// value.
+//
+LONG NV_API_CALL AosAtomicSet
+(
+    IN  PAOS_CONTEXT pAosContext,
+    IN  VOID* pAddr,
+    IN  ULONG Value
+)
+{
+    signed int oldvalue = atomic_read((atomic_t *) pAddr);
+    atomic_set((atomic_t *)pAddr,Value);
+    return oldvalue;
+}
+
+//*****************************************************************************
+// AosGetPhysicalAddr
+//*****************************************************************************
+void* NV_API_CALL AosGetPhysicalAddr
+(
+    IN PVOID pLinAddr
+    )
+{
+    return (void*) virt_to_phys(pLinAddr);
+}
+
+//*****************************************************************************
+// AosGetPhysicalAddr
+//*****************************************************************************
+void * NV_API_CALL AosGetLinearAddress(IN unsigned long physAddr)
+{
+    return (void *) phys_to_virt(physAddr);
+}
+
+
+
+//
+// Defining the NVA_SPINLOCK
+//
+struct NVA_SPINLOCK
+{
+    // spinlock variable
+    spinlock_t  Lock;
+    // This is the AOS context for the list.
+    PAOS_CONTEXT AosCtx;
+    // Set if the lock is acquired.
+    ULONG Locked;
+    // To save the flags at IRQ state
+    unsigned long flags;
+};
+//*****************************************************************************
+// AosSpinLockCreate
+//*****************************************************************************
+// Creates a new spin lock.
+// The spinlock must be freed with AosSpinLockFree.
+//
+unsigned long NV_API_CALL AosSpinLockCreate
+(
+    IN  PAOS_CONTEXT pAosContext,
+    IN  PNVA_SPINLOCK* ppSpinLock
+)
+{
+    *ppSpinLock =
+        (PNVA_SPINLOCK)AosMemoryAlloc(pAosContext, sizeof(struct NVA_SPINLOCK));
+    if(!*ppSpinLock)
+    {
+        printk("Nvsound: Failed to allocate the spinlock! \n");
+        *ppSpinLock = 0;
+        return NVA_INSUFFICIENT_RESOURCES;
+    }
+
+    (*ppSpinLock)->AosCtx = pAosContext;
+    (*ppSpinLock)->Locked = 0;
+    (*ppSpinLock)->flags  = 0;
+    spin_lock_init(&(*ppSpinLock)->Lock);
+    return NVA_OK;
+}
+
+//*****************************************************************************
+// AosSpinLockFree
+//*****************************************************************************
+// Releases an allocated spinlock.
+//
+VOID NV_API_CALL AosSpinLockFree
+(
+    IN  PNVA_SPINLOCK pSpinLock
+)
+{   
+    AosMemoryFree(pSpinLock->AosCtx, pSpinLock);
+}
+
+//*****************************************************************************
+// AosSpinLockAcquire
+//*****************************************************************************
+// Acquire the spin lock
+//
+VOID NV_API_CALL AosSpinLockAcquire
+(
+    IN  PNVA_SPINLOCK pSpinLock
+)
+{
+    if(pSpinLock){
+        spin_lock(&pSpinLock->Lock);
+        pSpinLock->Locked = 1;
+    }
+}
+
+//*****************************************************************************
+// AosSpinLockIsLocked
+//*****************************************************************************
+// This tells us if the locked is currently held.
+BOOL NV_API_CALL AosSpinLockIsLocked
+(
+    IN  PNVA_SPINLOCK pSpinLock
+)
+{
+    return (BOOL)pSpinLock->Locked;
+}
+
+//*****************************************************************************
+// AosSpinLockRelease
+//*****************************************************************************
+// Release the spin lock.
+//
+VOID NV_API_CALL AosSpinLockRelease
+(
+    IN  PNVA_SPINLOCK pSpinLock
+)
+{
+    if(pSpinLock){
+        pSpinLock->Locked = 0;
+        spin_unlock(&pSpinLock->Lock);
+    }
+}
+
+//*****************************************************************************
+// AosThreadDelay
+//*****************************************************************************
+// Delay the execution of the current thread by the specified number of
+// milliseconds.
+//
+VOID NV_API_CALL AosThreadDelay
+(
+    IN  PAOS_CONTEXT pAosContext,
+    IN  unsigned long Milliseconds
+)
+{
+    mdelay(Milliseconds);
+}
+
+//*****************************************************************************
+// AosDelay
+//*****************************************************************************
+// Stall the executing processor by the specified number of microseconds.
+//
+inline VOID NV_API_CALL AosDelay
+(
+    IN  PAOS_CONTEXT pAosContext,
+    IN  unsigned long Microseconds
+)
+{
+    // using udelay now - have to look whether any function to stall the processor if neccessary.
+    udelay(Microseconds);
+
+}
+
+//*****************************************************************************
+// AosPeek8
+//*****************************************************************************
+// Read an 8-bit value from the specified address.
+//
+unsigned char NV_API_CALL AosPeek8
+(
+    IN  PAOS_CONTEXT pAosContext,
+    IN  VOID * pAddr
+)
+{
+    return (unsigned char)inb((unsigned long)pAddr);
+}
+
+//*****************************************************************************
+// AosPeek16
+//*****************************************************************************
+// Read a 16-bit value from the specified address.
+//
+unsigned short NV_API_CALL AosPeek16
+(
+    IN  PAOS_CONTEXT pAosContext,
+    IN  VOID * pAddr
+)
+{
+    return (unsigned short)inw((unsigned long)pAddr);
+}
+
+//*****************************************************************************
+// AosPeek32
+//*****************************************************************************
+// Read a 32-bit value from the specified address.
+//
+unsigned int NV_API_CALL AosPeek32
+(
+    IN  PAOS_CONTEXT pAosContext,
+    IN  VOID * pAddr
+)
+{
+    return (unsigned int)inl((unsigned long)pAddr);
+}
+
+//*****************************************************************************
+// AosPoke8
+//*****************************************************************************
+// Write an 8-bit value to the specified address.
+//
+VOID NV_API_CALL AosPoke8
+(
+    IN  PAOS_CONTEXT pAosContext,
+    IN  VOID * pAddr,
+    IN  unsigned char Value
+)
+{
+    outb(Value,(unsigned long)pAddr);
+}
+
+//*****************************************************************************
+// AosPoke16
+//*****************************************************************************
+// Write a 16-bit value to the specified address.
+//
+VOID NV_API_CALL AosPoke16
+(
+    IN  PAOS_CONTEXT pAosContext,
+    IN  VOID * pAddr,
+    IN  unsigned short Value
+)
+{
+    outw(Value,(unsigned long)pAddr);
+}
+
+//*****************************************************************************
+// AosPoke32
+//*****************************************************************************
+// Write a 32-bit value to the specified address.
+//
+VOID NV_API_CALL AosPoke32
+(
+    IN  PAOS_CONTEXT pAosContext,
+    IN  VOID * pAddr,
+    IN  ULONG Value
+)
+{
+    outl(Value,(unsigned long)pAddr);
+}
+
+//*****************************************************************************
+// AosFpRestore
+//*****************************************************************************
+VOID NV_API_CALL AosFpRestore(IN  PAOS_CONTEXT pAosContext)
+{
+}
+
+//*****************************************************************************
+// AosFpSave
+//*****************************************************************************
+VOID NV_API_CALL AosFpSave(IN  PAOS_CONTEXT pAosContext)
+{
+}
+
+//*****************************************************************************
+// AosInterruptStatePop
+//*****************************************************************************
+VOID NV_API_CALL AosInterruptStatePop(IN  PAOS_CONTEXT pAosContext,IN  NVA_INTERRUPT_STATE State)
+{
+    spin_unlock_irqrestore(&global_spinlock,global_flags);
+    global_spinlock = SPIN_LOCK_UNLOCKED;
+}
+
+//*****************************************************************************
+// AosInterruptStatePush
+//*****************************************************************************
+VOID NV_API_CALL AosInterruptStatePush(IN  PAOS_CONTEXT pAosContext,IN  NVA_INTERRUPT_STATE* pState)
+{
+    spin_lock_irqsave(&global_spinlock,global_flags);
+}
+
+//*****************************************************************************
+// AosMemoryPhysicalAddressListGet
+//*****************************************************************************
+VOID NV_API_CALL AosMemoryPhysicalAddressListGet
+(  IN  PAOS_CONTEXT pAosContext,
+   IN  VOID * pKernelAddress,
+   IN  ULONG Size,
+   IN  PNVA_AST* ppPhysicalAddressList,
+   IN  ULONG* pNumberOfPhysicalAddressListEntries
+)
+{
+	PNVA_AST  pPhysicalArray, addrArray;
+    ULONG prds = 0, arraysize = 0, icount = 0;
+	unsigned long phys_addr = 0, virt_addr = 0, isvmalloc = 0;
+    
+
+    ASSERT(pKernelAddress);
+    ASSERT(ppPhysicalAddressList);
+    ASSERT(pNumberOfPhysicalAddressListEntries);
+
+    *ppPhysicalAddressList = 0;
+    *pNumberOfPhysicalAddressListEntries = 0;
+
+	prds = COMPUTE_PAGES_SPANNED(pKernelAddress, Size);
+
+    // Create the list for the array to store the page's physical addr
+    arraysize = (sizeof(NVA_AST)* (prds + 1));
+    addrArray = (PNVA_AST) AosMemoryAlloc(0,arraysize);
+    if(addrArray) {
+        AosMemoryZero(0,addrArray,arraysize);
+    }
+    else {
+        printk(KERN_INFO "Nvsound: Unable to allocate the memory prd list-  ");
+        return;
+    }
+
+    // Save the size
+    *addrArray = Size;
+    addrArray++;
+    pPhysicalArray = addrArray;
+
+	//
+	// Verify the address is vmalloced one
+	//
+	virt_addr = (unsigned long)pKernelAddress;
+	if( virt_addr >= VMALLOC_START && virt_addr < VMALLOC_END) 
+		isvmalloc = 1;
+	
+    //
+    // Obtain the physical address from virtual address.
+    //
+#if defined (__i386__)
+	if(isvmalloc){
+		for(icount = 0; icount < prds ; icount++) {
+			phys_addr = nv_get_kern_phys_address(virt_addr);
+			if(phys_addr == 0){
+				printk(KERN_INFO "Nvsound: Unable to allocate the physical memory-  ");
+				return;
+			}
+			*pPhysicalArray = (u32)phys_addr;
+			pPhysicalArray++;
+			virt_addr += PAGE_SIZE;
+		}
+	}else 
+#endif
+	{
+		for(icount = 0; icount < prds ; icount++) {
+			*pPhysicalArray = (u32) virt_to_phys((char *)pKernelAddress+(icount*PAGE_SIZE));
+			pPhysicalArray++;
+		} 
+	}
+
+    *ppPhysicalAddressList = addrArray;
+    *pNumberOfPhysicalAddressListEntries = prds;
+    return;
+
+}
+
+//*****************************************************************************
+// AosMemoryPhysicalAddressListFree
+//*****************************************************************************
+VOID NV_API_CALL AosMemoryPhysicalAddressListFree(IN  PAOS_CONTEXT pAosContext,IN  PNVA_AST pPhysicalAddressList)
+{
+    ULONG uSize;
+    PNVA_AST pPhysArray;
+    
+    ASSERT(pPhysicalAddressList);
+    
+    // find the number of prds first
+    if(pPhysicalAddressList){
+        //printk(KERN_INFO "Nvsound: Phy Array %x ", (unsigned long)pPhysicalAddressList);
+        pPhysArray = (PNVA_AST)(pPhysicalAddressList - 1);
+        uSize      = *pPhysArray;
+        //printk(KERN_INFO "Nvsound: AosMemoryFreePhysical- Size 0x%x VA 0x%x PA 0x%x",uSize,(unsigned long)pKernelAddress,(unsigned long)dmaHandle);
+        AosMemoryFree(0,pPhysArray);
+    }
+}
+
+//*****************************************************************************
+// AosMemoryAllocPhysical
+//*****************************************************************************
+VOID NV_API_CALL AosMemoryAllocPhysical
+(
+    IN  PAOS_CONTEXT pAosContext,
+    IN  ULONG Size,
+    IN  NVA_U64 LowAddress,
+    IN  NVA_U64 HighAddress,
+    IN  VOID ** ppKernelAddress,
+    IN  VOID ** ppUserAddress,
+    IN  PNVA_AST* ppPhysicalAddressList,
+    IN  PULONG pNumberOfPhysicalAddressListEntries,
+    IN  MEMORY_CACHING_TYPE CacheType
+)
+{
+    struct page *pgend, *pgcount;
+    PNVA_AST  pPhysicalArray, addrArray;
+    void      *addr;
+    ULONG prds = 0, newSize = 0, icount = 0, arraysize = 0;
+    dma_addr_t dmaHandle;
+    newSize = ROUND_TO_PAGES(Size);
+
+    ASSERT(ppKernelAddress);
+    ASSERT(ppPhysicalAddressList);
+    ASSERT(pNumberOfPhysicalAddressListEntries);
+
+    // alloc memory
+    addr = pci_alloc_consistent(pAci_device,newSize,&dmaHandle);
+    if(addr) {
+        prds = COMPUTE_PAGES_SPANNED(addr,newSize);
+    }
+    
+    // Create the list for the array to store the page's physical addr
+    arraysize = (sizeof(NVA_AST)* (prds + 1));
+    addrArray = (PNVA_AST) AosMemoryAlloc(0,arraysize);
+    if(addrArray) {
+        AosMemoryZero(0,addrArray,arraysize);
+    }
+    else {
+        printk(KERN_INFO "Nvsound: Unable to allocate the memory-  ");
+		pci_free_consistent(pAci_device,newSize ,addr,dmaHandle);   
+		return;
+    }
+    // Save the size
+    *addrArray = newSize;
+    addrArray++;
+    pPhysicalArray = addrArray;
+    
+    // mark the pages are reserved now - not marking now
+    if(CacheType == MmCached) {
+        pgend = virt_to_page((u8 *)addr + (newSize-1));
+        for( pgcount = virt_to_page(addr); pgcount <= pgend; pgcount++) {
+			SetPageReserved(pgcount);
+        }
+    }
+
+    for(icount = 0; icount < prds ; icount++) {
+        *pPhysicalArray = (u32)dmaHandle +(icount*PAGE_SIZE);
+        pPhysicalArray++;
+    } 
+    //printk(KERN_INFO "Nvsound: AosMemoryPhysical- Size 0x%x VA 0x%lx PA 0x%lx prdlist 0x%x Prds 0x%x \n",
+    //            newSize,(unsigned long)addr,(unsigned long)dmaHandle,pPhysicalArray,prds);
+    *ppKernelAddress       = addr;
+    *ppPhysicalAddressList = addrArray;
+    *pNumberOfPhysicalAddressListEntries = prds;
+    
+    
+}
+
+//*****************************************************************************
+// AosVmAllocPhysical
+//*****************************************************************************
+VOID NV_API_CALL AosVmAllocPhysical
+(
+    IN  ULONG Size,
+    IN  VOID ** ppKernelAddress,
+    IN  PNVA_AST* ppPhysicalAddressList,
+    IN  PULONG pNumberOfPhysicalAddressListEntries
+)
+{
+#if defined (__i386__)
+
+	PNVA_AST  pPhysicalArray, addrArray;
+	void *addr = 0;
+	unsigned long phys_addr = 0, virt_addr = 0;
+	ULONG prds = 0, newSize = 0, icount = 0, arraysize = 0, rcount = 0;
+
+	newSize = ROUND_TO_PAGES(Size);
+
+	// alloc memory
+    addr = vmalloc_32(newSize);
+	virt_addr = (unsigned long) addr;
+    if(virt_addr) {
+        prds = COMPUTE_PAGES_SPANNED(addr,newSize);
+		memset(addr,0,newSize);
+	}else{
+		printk("Unable to allocate the vmalloc memory \n");
+		return;
+	}
+
+	// Create the list for the array to store the page's physical addr
+    arraysize = (sizeof(NVA_AST)* (prds + 1));
+    addrArray = (PNVA_AST) AosMemoryAlloc(0,arraysize);
+    if(addrArray) {
+        AosMemoryZero(0,addrArray,arraysize);
+    }
+    else {
+        printk(KERN_INFO "Nvsound: Unable to allocate the memory-  ");
+		AosMemoryFree(0,addr);
+		return;
+    }
+    
+	// Save the size
+    *addrArray = newSize;
+    addrArray++;
+    pPhysicalArray = addrArray;
+
+	for(icount = 0; icount < prds ; icount++) {
+		phys_addr = nv_get_kern_phys_address(virt_addr);
+		//printk("%lx \n", phys_addr);
+		if(phys_addr == 0){
+			printk(KERN_INFO "Nvsound: Unable to allocate the physical memory-  ");
+			goto failed;
+		}
+		/* lock the page for dma purposes */
+        SetPageReserved(NV_GET_PAGE_STRUCT(phys_addr));
+
+        *pPhysicalArray = (u32)phys_addr;
+        pPhysicalArray++;
+
+		// This will work only in 32bit version.
+		// Need changes for 64bit
+		NV_SET_PAGE_ATTRIB_UNCACHED(phys_addr);
+		
+		virt_addr += PAGE_SIZE;
+    } 
+    
+	nv_flush_caches();
+
+	//printk(KERN_INFO "Nvsound: AosVmAllocPhysical- Size 0x%x VA 0x%p Prds 0x%x \n",
+    //            newSize,addr,prds);
+    *ppKernelAddress       = addr;
+    *ppPhysicalAddressList = addrArray;
+    *pNumberOfPhysicalAddressListEntries = prds;
+	
+	return;
+
+failed:
+	pPhysicalArray = addrArray;	
+	virt_addr = (unsigned long) addr;
+	for(rcount = 0; rcount < icount; rcount++)	{
+		phys_addr  = (unsigned long)*pPhysicalArray;
+		ClearPageReserved(NV_GET_PAGE_STRUCT(phys_addr));
+		NV_SET_PAGE_ATTRIB_CACHED(phys_addr);
+		pPhysicalArray++;
+	}
+	
+	nv_flush_caches();
+
+	AosMemoryFree(0,addr); 
+	AosMemoryFree(0,addrArray);
+
+#else //defined (__x86_64__)
+	AosMemoryAllocPhysical(0, Size, 0x00000000, 0xffffffff, ppKernelAddress, 0, ppPhysicalAddressList, pNumberOfPhysicalAddressListEntries,MmCached);
+#endif
+
+}
+
+
+//*****************************************************************************
+// AosVmFreePhysical
+//*****************************************************************************
+VOID NV_API_CALL AosVmFreePhysical
+(
+    IN  VOID * pKernelAddress,
+    IN  PNVA_AST pPhysicalAddressList
+)
+{
+#if defined (__i386__)
+
+    ULONG uSize, prds = 0, icount = 0;
+	unsigned long phys_addr = 0;
+    PNVA_AST pPhysArray, pPhysList;
+    
+    
+    // find the number of prds first
+    if(pPhysicalAddressList){
+        pPhysArray = (PNVA_AST)(pPhysicalAddressList - 1);
+        uSize      = *pPhysArray;
+		pPhysList  = pPhysicalAddressList;
+		prds = COMPUTE_PAGES_SPANNED(pKernelAddress,uSize);
+		
+		for(icount = 0; icount < prds ; icount++) {
+			phys_addr  = (unsigned long)*pPhysList;
+			ClearPageReserved(NV_GET_PAGE_STRUCT(phys_addr));
+			NV_SET_PAGE_ATTRIB_CACHED(phys_addr);
+			pPhysList++;
+		}
+
+		nv_flush_caches();
+
+        AosMemoryFree(0,pKernelAddress);   
+        AosMemoryFree(0,pPhysArray);
+    }
+
+#else //defined (__x86_64__)
+	AosMemoryFreePhysical(0, pKernelAddress, (ULONG32)MmCached, pPhysicalAddressList);
+#endif
+}
+//*****************************************************************************
+// AosMemoryFreePhysical
+//*****************************************************************************
+VOID NV_API_CALL AosMemoryFreePhysical
+(
+    IN  PAOS_CONTEXT pAosContext,
+    IN  VOID * pKernelAddress,
+    IN  ULONG CacheValue,
+    IN  PNVA_AST pPhysicalAddressList
+)
+{
+    ULONG uSize;
+    dma_addr_t dmaHandle;
+    PNVA_AST pPhysArray;
+    struct page *pgend, *pgcount;
+    MEMORY_CACHING_TYPE CacheType;
+
+    ASSERT(pKernelAddress);
+    ASSERT(pPhysicalAddressList);
+    
+    // find the number of prds first
+    if(pPhysicalAddressList){
+        //printk(KERN_INFO "Nvsound: Phy Array %x ", (unsigned long)pPhysicalAddressList);
+        pPhysArray = (PNVA_AST)(pPhysicalAddressList - 1);
+        uSize      = *pPhysArray;
+        dmaHandle  = *pPhysicalAddressList;
+        //printk(KERN_INFO "Nvsound: AosMemoryFreePhysical- Size 0x%x VA 0x%x PA 0x%x",uSize,(unsigned long)pKernelAddress,(unsigned long)dmaHandle);
+
+        // unmark the pages are reserved now
+        if(CacheValue) {
+            CacheType = (MEMORY_CACHING_TYPE)CacheValue ;
+            if(CacheType == MmCached){
+                pgend = virt_to_page((u8 *)pKernelAddress + (uSize-1));
+                for( pgcount = virt_to_page(pKernelAddress); pgcount <= pgend; pgcount++) {
+                    ClearPageReserved(pgcount);
+                }
+            }
+        }
+        pci_free_consistent(pAci_device,uSize ,pKernelAddress,dmaHandle);   
+        AosMemoryFree(0,pPhysArray);
+    }
+
+}
+
+//*****************************************************************************
+// AosDelayThread
+//*****************************************************************************
+VOID  NV_API_CALL AosDelayThread(IN  PAOS_CONTEXT pAosContext,IN  unsigned long Microseconds)
+{
+
+}
+
+//*****************************************************************************
+// AosDebugPrint
+//*****************************************************************************
+VOID NV_API_CALL AosDebugPrint
+(
+    IN  char * Format, ...
+)
+{
+    //
+    // Write the string to a buffer.
+    //
+    char buffer[256];
+    va_list vaList;
+    ULONG size  = 0;
+
+    AosMemoryZero(NULL,&buffer,256);
+    va_start(vaList, Format);
+    vsnprintf(buffer, sizeof(buffer), Format, vaList);
+    va_end(vaList);
+    size = strlen(buffer);
+    printk(KERN_INFO "%s ",buffer);
+    return;
+}
+
+//*****************************************************************************
+// AosSprintf
+//*****************************************************************************
+int NV_API_CALL AosSprintf
+(
+    IN char *       string,
+    IN const char * format,
+    ...
+)
+{
+    int chars_written = 0;
+    va_list arglist;
+
+    va_start(arglist, format);
+    chars_written = sprintf(string, format, arglist);
+    va_end(arglist);
+
+    return chars_written;
+}
+
+//*****************************************************************************
+// AosStrcpy
+//*****************************************************************************
+char* NV_API_CALL AosStrcpy(char *dest, const char *src)
+{
+    return strcpy(dest,src);
+}
+
+//*****************************************************************************
+// AosStrlen
+//*****************************************************************************
+int NV_API_CALL AosStrlen(char *src)
+{
+    return (int)strlen((const char *)src);
+}
+
+//*****************************************************************************
+// AosStrcat
+//*****************************************************************************
+char* NV_API_CALL AosStrcat(char *dest, const char *src)
+{
+    return strcat(dest,src);
+}
+
+//*****************************************************************************
+// AosStrcmp
+//*****************************************************************************
+int NV_API_CALL  AosStrcmp(const char *s1, const char *s2)
+{
+    return strcmp(s1,s2);
+}
+
+//*****************************************************************************
+// AosMemCpyFromUsr
+//*****************************************************************************
+int NV_API_CALL AosMemCpyFromUsr(void *dest,const void* src,ULONG length)
+{
+    return copy_from_user(dest, src, length);
+}
+
+//*****************************************************************************
+// AosMemCpyToUsr
+//*****************************************************************************
+int NV_API_CALL AosMemCpyToUsr(void *dest,const void* src,ULONG length)
+{
+    return copy_to_user(dest, src, length);
+}
+
+//*****************************************************************************
+// AosSetPciDevice
+//*****************************************************************************
+// Function to  set the pci_dev
+VOID NV_API_CALL AosSetPciDevice(VOID * pAciDev,VOID * pApuDev)
+{
+    pAci_device = (struct pci_dev *)pAciDev;
+    pApu_device = (struct pci_dev *)pApuDev;
+    //printk(KERN_INFO "Nvsound: Aci_device %p Apu_device %p \n",pAci_device,pApu_device);
+}
+
+//*****************************************************************************
+// AosClearPciDevice
+//*****************************************************************************
+// Function to reset the pci_dev
+VOID NV_API_CALL AosResetPciDevice()
+{
+    pAci_device = 0;
+    pApu_device = 0;
+}
+
+//*****************************************************************************
+// AosReadPciConfig
+//*****************************************************************************
+// Function to read the data from pci-config space
+VOID NV_API_CALL AosReadPciConfig
+(   
+    IN VOID * pDevice, IN ULONG *pValue,
+    IN ULONG uRegIndex, IN ULONG uLength
+)
+{
+    // set the pci_dev first
+    struct pci_dev * pdevice = (struct pci_dev *) pDevice;
+
+    ASSERT(pDevice);
+
+    switch(uLength){
+        case (sizeof(DWORD)):
+            pci_read_config_dword(pdevice,uRegIndex,(u32 *)pValue);
+            break;
+        default:
+            *pValue = 0;
+    }
+}
+
+//*****************************************************************************
+// AosWritePciConfig
+//*****************************************************************************
+// Function to write the data to pci-config space
+VOID NV_API_CALL AosWritePciConfig
+(
+    IN VOID * pDevice,IN ULONG uValue,
+    IN ULONG uRegIndex, IN ULONG uLength
+)
+{
+    struct pci_dev * pdevice = (struct pci_dev *) pDevice;
+
+    ASSERT(pDevice);
+
+    // set the pci_dev first
+    switch(uLength){
+        case (sizeof(DWORD)):
+            pci_write_config_dword(pdevice,uRegIndex,uValue);
+            break;
+        default:
+            uValue = 0;
+    }
+
+}
+
+//*****************************************************************************
+// AosSetApuResources
+//*****************************************************************************
+// Function to set the APU RESOURCES
+VOID NV_API_CALL AosSetApuResources(IN DEVICE_RESOURCES* device)
+{
+    AosResetApuResources();
+    apu_res.uPhyAddr = device->uPhyAddr;
+    apu_res.uLength  = device->uLength;
+    apu_res.uIrq     = device->uIrq;
+}
+
+//*****************************************************************************
+// AosResetApuResources
+//*****************************************************************************
+// Function to reset the APU RESOURCES
+VOID NV_API_CALL AosResetApuResources(IN VOID)
+{
+    apu_res.uPhyAddr = 0;
+    apu_res.uLength  = 0;
+    apu_res.uIrq     = 0;
+}
+
+//*****************************************************************************
+// AosGetApuResources
+//*****************************************************************************
+// Function to get the APU RESOURCES
+VOID NV_API_CALL AosGetApuResources(IN DEVICE_RESOURCES* device)
+{
+    device->uPhyAddr = apu_res.uPhyAddr;
+    device->uLength  = apu_res.uLength ;
+    device->uIrq     = apu_res.uIrq;
+}
+
+//*****************************************************************************
+// AosMapLinearAddress
+//*****************************************************************************
+// Function to map the physical to linear address
+unsigned long NV_API_CALL AosMapLinearAddress(VOID *pPhys, ULONG uSize, VOID**ppLinear)
+{
+    *ppLinear = ioremap((unsigned long)pPhys, (ULONG) uSize);
+    ApuLinearAddress = (VOID *)*ppLinear;
+    return (*ppLinear)?NVA_OK:NVA_ERR;
+}
+
+//*****************************************************************************
+// AosUnmapLinearAddress
+//*****************************************************************************
+// Unmap the linear address
+VOID NV_API_CALL AosUnmapLinearAddress(VOID *pLinear)
+{
+    if(pLinear)
+        iounmap(pLinear);
+    ApuLinearAddress = 0;
+}
+
+
+//****************************************
+//    AosGetLinearAddress
+//*****************************************
+VOID * NV_API_CALL AosGetLinearBase(VOID)
+{
+    return ApuLinearAddress;
+}
+
+//****************************************
+//    AosSetVapu
+//*****************************************
+VOID NV_API_CALL AosSetVapu(unsigned int value)
+{
+	setvapu = value;
+}
+
+//****************************************
+//    AosTimerCreate
+//*****************************************
+unsigned long NV_API_CALL AosTimerCreate(IN  PAOS_CONTEXT pAosContext,IN  VOID * pContext,
+    IN  PAOS_TIMER_CALLBACK pCallback,IN  PNVA_TIMER* ppTimer)
+{
+    struct timer_list *new_timer = (struct timer_list *)AosMemoryAlloc(pAosContext,sizeof(struct timer_list));
+    *ppTimer =
+        (PNVA_TIMER)AosMemoryAlloc(pAosContext, sizeof(NVA_TIMER));
+    if(!*ppTimer)
+    {
+        printk("Nvsound: Failed to allocate the timer! \n");
+        *ppTimer = 0;
+        return NVA_INSUFFICIENT_RESOURCES;
+    }
+
+    init_timer(new_timer);
+
+    new_timer->function   = (VOID *)pCallback;
+    new_timer->data       = (unsigned long)pContext;
+    (*ppTimer)->AosCtx    = pAosContext;
+    (*ppTimer)->Timer     = new_timer;
+    (*ppTimer)->Last_Time = 0;
+
+    return NVA_OK;
+}
+
+//****************************************
+//    AosTimerFree
+//*****************************************
+VOID NV_API_CALL AosTimerFree(IN  PNVA_TIMER pTimer)
+{
+    del_timer(pTimer->Timer);
+    AosMemoryFree(pTimer->AosCtx, pTimer->Timer);
+    AosMemoryFree(pTimer->AosCtx, pTimer);
+}
+
+//****************************************
+//    AosTimerSet
+//*****************************************
+BOOL NV_API_CALL AosTimerSet(IN  PNVA_TIMER pTimer,IN  unsigned long DueTimeInMilliseconds,
+    IN  unsigned long PeriodicTimeInMilliseconds,IN  BOOL ResetTimer)
+{
+
+    pTimer->Timer->expires = jiffies + ((DueTimeInMilliseconds * HZ) / 1000);
+    if(!ResetTimer) {
+        if(pTimer->Timer->expires > pTimer->Last_Time) {
+            pTimer->Last_Time = pTimer->Timer->expires;
+            add_timer(pTimer->Timer);
+            return TRUE;
+        }
+    }else { // reset an existing timer
+        if(pTimer->Timer->expires > pTimer->Last_Time) {
+            pTimer->Last_Time = pTimer->Timer->expires;
+            mod_timer(pTimer->Timer,pTimer->Timer->expires);
+            return TRUE;
+        }
+    }
+    return FALSE;
+}
+
+
+#ifdef __cplusplus
+};
+#endif
+
+#undef ASSERT
diff -Naur NFORCE-Linux-x86-1.0-0310-pkg1.old/nvsound/main/nvalinux.h NFORCE-Linux-x86-1.0-0310-pkg1/nvsound/main/nvalinux.h
--- NFORCE-Linux-x86-1.0-0310-pkg1.old/nvsound/main/nvalinux.h	2005-10-21 20:59:44.000000000 -0500
+++ NFORCE-Linux-x86-1.0-0310-pkg1/nvsound/main/nvalinux.h	2008-08-14 10:13:48.000000000 -0500
@@ -43,7 +43,6 @@
 	typedef  long LONG_PTR, *PLONG_PTR, INT_PTR, *PINT_PTR;
     typedef  unsigned long ULONG_PTR, *PULONG_PTR, UINT_PTR, *PUINT_PTR;
     #define __int3264   __int32
-    typedef unsigned int     uintptr_t;
 	
 #else
     typedef long long int INT_PTR, *PINT_PTR;
diff -Naur NFORCE-Linux-x86-1.0-0310-pkg1.old/nvsound/main/nvalinux.h.orig NFORCE-Linux-x86-1.0-0310-pkg1/nvsound/main/nvalinux.h.orig
--- NFORCE-Linux-x86-1.0-0310-pkg1.old/nvsound/main/nvalinux.h.orig	1969-12-31 18:00:00.000000000 -0600
+++ NFORCE-Linux-x86-1.0-0310-pkg1/nvsound/main/nvalinux.h.orig	2005-10-21 20:59:44.000000000 -0500
@@ -0,0 +1,335 @@
+/* _NVIDIA_COPYRIGHT_BEGIN_
+ *
+ * Copyright 2003-2004 by NVIDIA Corporation.  All rights reserved.  All
+ * information contained herein is proprietary and confidential to NVIDIA
+ * Corporation.  Any use, reproduction, or disclosure without the written
+ * permission of NVIDIA Corporation is prohibited.
+ *
+ * _NVIDIA_COPYRIGHT_END_
+ */
+
+/*
+* nvalinux.h
+*
+* Header file for defining our own function call to call kernel functions
+*
+*/
+
+#if !defined __NVALINUX_H_
+#define __NVALINUX_H_
+
+#if defined __cplusplus
+extern "C" {
+#endif
+
+#if !defined IN
+#define IN
+#endif
+
+#if !defined OUT
+#define OUT
+#endif
+
+#if !defined __int64
+#define __int64 long long int
+#endif
+
+typedef __int64          LONGLONG;
+
+#if defined (__i386__)
+    /* need to specify INT_PTR as long as we care about 32bits only -
+		otherwise it will cause some overloading errors
+	*/
+	typedef  long LONG_PTR, *PLONG_PTR, INT_PTR, *PINT_PTR;
+    typedef  unsigned long ULONG_PTR, *PULONG_PTR, UINT_PTR, *PUINT_PTR;
+    #define __int3264   __int32
+    typedef unsigned int     uintptr_t;
+	
+#else
+    typedef long long int INT_PTR, *PINT_PTR;
+    typedef unsigned long long int UINT_PTR, *PUINT_PTR;
+    typedef __int64 LONG_PTR, *PLONG_PTR;
+    typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;
+    #define __int3264   __int64
+    typedef unsigned __int64 uintptr_t;
+#endif
+
+#if !defined PCHAR
+#define PCHAR char*
+#endif
+
+#if !defined NVA_OK
+#define NVA_OK 0
+#endif
+
+#if !defined VOID
+#define VOID void
+#endif
+
+// make sure the arguments are expected in stack instead of registers
+#if !defined(NV_API_CALL)
+#if defined(__i386__)
+#define NV_API_CALL __attribute__((regparm(0)))
+#else
+#define NV_API_CALL
+#endif
+#endif
+
+struct AOS_CONTEXT
+{
+    unsigned long uFlags;
+};
+typedef struct AOS_CONTEXT *PAOS_CONTEXT;
+
+typedef struct _DEVICE_RESOURCES
+{   
+    unsigned long uPhyAddr;
+    unsigned int iobase0;
+    unsigned int iobase1;
+    unsigned int uLength;
+    unsigned int uIrq;
+}DEVICE_RESOURCES;
+
+typedef struct _NEW_MEM_HEADER
+{
+    VOID * pVirtualAddr;
+    VOID * pPhysArray;
+}NEW_MEM_HEADER;
+
+#define NVA_ERR                     900
+#define NVA_NO_INTERFACE            901
+#define NVA_NOT_IMPLEMENTED         902
+#define NVA_INVALID_PARAMETER       903
+#define NVA_INSUFFICIENT_RESOURCES  904
+#define NVA_INVALID_DEVICE_STATE    905
+
+#if !defined TRUE
+#define TRUE 1
+#endif
+
+#if !defined FALSE
+#define FALSE 0
+#endif
+
+typedef signed int LONG32, *PLONG32;
+typedef unsigned int ULONG32, *PULONG32;
+typedef unsigned int DWORD32, *PDWORD32;
+
+typedef unsigned int     DWORD;
+typedef unsigned int     ULONG;
+typedef int              LONG;
+typedef int              BOOL;
+typedef unsigned char    BOOLEAN;
+typedef unsigned char    BYTE;
+typedef float            FLOAT;
+typedef LONGLONG         REFERENCE_TIME;
+typedef unsigned short   WORD;
+
+
+typedef DWORD  *PDWORD;
+typedef BOOL   *LPBOOL, *PBOOL;
+typedef BYTE   *PBYTE, *LPBYTE;
+typedef VOID   *PVOID, *LPVOID;
+typedef ULONG  *PULONG;
+
+typedef __int64 LONG64, *PLONG64;
+typedef unsigned __int64 ULONG64, *PULONG64;
+typedef unsigned __int64 DWORD64, *PDWORD64;
+
+
+typedef ULONG_PTR NVA_AST;
+typedef NVA_AST *PNVA_AST;
+
+//
+// This is the timer callback declaration.
+//
+typedef VOID (*PAOS_TIMER_CALLBACK)
+(
+    IN  VOID* pContext
+);
+
+typedef struct _NVA_TIMER_
+{
+    PAOS_CONTEXT AosCtx;
+
+    //
+    // The timer.
+    //
+    struct timer_list *Timer;
+
+    //
+    // Last time
+    //
+    unsigned long Last_Time;
+
+}NVA_TIMER;
+typedef NVA_TIMER *PNVA_TIMER;
+
+//
+// "void": enumerated or multiple fields
+//
+typedef struct
+{
+    unsigned long Low;
+    unsigned long High;
+
+} NVA_V64, *PNVA_V64;
+
+//
+// 0 to 18446744073709551615
+//
+typedef unsigned __int64 NVA_U64;
+typedef NVA_U64* PNVA_U64;
+
+//
+// 2^-63 to 2^63-1
+//
+typedef __int64 NVA_S64;
+typedef NVA_S64* PNVA_S64;
+
+//
+// 64-bit void pointer
+//
+typedef struct
+{
+    unsigned long Low;
+    unsigned long High;
+
+} NVA_P64, *PNVA_P64;
+
+struct NVA_SPINLOCK;
+typedef struct NVA_SPINLOCK* PNVA_SPINLOCK;
+
+typedef unsigned long NVA_INTERRUPT_STATE;
+typedef NVA_INTERRUPT_STATE* PNVA_INTERRUPT_STATE;
+
+#define MAX_PATH   260
+
+#if defined __cplusplus
+void* operator new  (IN size_t iSize);
+void  operator delete (IN PVOID pAddr);
+#endif
+
+typedef enum _MEMORY_CACHING_TYPE {
+  MmNonCached,
+  MmCached,
+  MmWriteCombined
+} MEMORY_CACHING_TYPE;
+
+#ifdef DEFINE_GLOBAL_VARS
+struct AOS_CONTEXT AosContext;
+#else
+extern struct AOS_CONTEXT AosContext;
+#endif
+
+#if !defined PAGE_ALIGN
+#define PAGE_ALIGN(Va) ((PVOID)((ULONG_PTR)(Va) & ~(PAGE_SIZE - 1)))
+#endif
+
+#if !defined ROUND_TO_PAGES
+#define ROUND_TO_PAGES(Size)  (((ULONG_PTR)(Size) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))
+#endif
+
+#if !defined COMPUTE_PAGES_SPANNED
+#define COMPUTE_PAGES_SPANNED(Va, Size) \
+    ((ULONG)((((ULONG_PTR)(Va) & (PAGE_SIZE -1)) + (Size) + (PAGE_SIZE - 1)) >> PAGE_SHIFT))
+#endif
+
+
+VOID* NV_API_CALL AosMemoryAlloc(IN  PAOS_CONTEXT pAosContext,IN  ULONG Size);
+
+VOID* NV_API_CALL AosMemoryAllocVM(IN  PAOS_CONTEXT pAosContext,IN  ULONG Size);
+VOID* NV_API_CALL AosMemoryAllocAtomic(IN  PAOS_CONTEXT pAosContext,IN  ULONG Size);
+VOID  NV_API_CALL AosMemoryFree  (IN  PAOS_CONTEXT pAosContext,IN  VOID * pAddr);
+VOID  NV_API_CALL AosMemoryZero(IN  PAOS_CONTEXT pAosContext,IN  VOID * pData,IN  ULONG Size);
+VOID  NV_API_CALL AosMemoryCopy(IN  PAOS_CONTEXT pAosContext,IN  VOID * pDestination, IN  VOID * pSource,IN  ULONG Size);
+BOOL  NV_API_CALL AosMemoryCompare(IN  PAOS_CONTEXT pAosContext,IN  VOID * pSource1,IN  VOID * pSource2,IN  ULONG Length);
+VOID  NV_API_CALL AosMemorySet(IN  PAOS_CONTEXT pAosContext,IN VOID * pDestination,IN  VOID * pData,IN  ULONG Length);
+VOID* NV_API_CALL AosGetPhysicalAddr(IN PVOID pLinAddr);
+VOID* NV_API_CALL AosGetLinearAddress(IN unsigned long PhysAddr);
+
+LONG   NV_API_CALL AosAtomicDecrement(IN  PAOS_CONTEXT pAosContext,IN  VOID *pAddr);
+LONG   NV_API_CALL AosAtomicIncrement(IN  PAOS_CONTEXT pAosContext,IN  VOID *pAddr);
+LONG   NV_API_CALL AosAtomicSet(IN  PAOS_CONTEXT pAosContext,IN  VOID *pAddr,IN  ULONG Value);
+
+unsigned long NV_API_CALL AosSpinLockCreate(IN  PAOS_CONTEXT pAosContext,IN  PNVA_SPINLOCK* ppSpinLock);
+VOID   NV_API_CALL AosSpinLockFree(IN  PNVA_SPINLOCK pSpinLock);
+VOID   NV_API_CALL AosSpinLockAcquire(IN  PNVA_SPINLOCK pSpinLock);
+BOOL   NV_API_CALL AosSpinLockIsLocked(IN  PNVA_SPINLOCK pSpinLock);
+VOID   NV_API_CALL AosSpinLockRelease(IN  PNVA_SPINLOCK pSpinLock);
+VOID   NV_API_CALL AosDelay(IN  PAOS_CONTEXT pAosContext,IN  unsigned long Microseconds);
+VOID   NV_API_CALL AosDelayThread(IN  PAOS_CONTEXT pAosContext,IN  unsigned long Microseconds);
+
+VOID   NV_API_CALL AosFpRestore(IN  PAOS_CONTEXT pAosContext);
+VOID   NV_API_CALL AosFpSave(IN  PAOS_CONTEXT pAosContext);
+VOID   NV_API_CALL AosInterruptStatePop(IN  PAOS_CONTEXT pAosContext,IN  NVA_INTERRUPT_STATE State);
+VOID   NV_API_CALL AosInterruptStatePush(IN  PAOS_CONTEXT pAosContext,IN  NVA_INTERRUPT_STATE* pState);
+VOID   NV_API_CALL AosMemoryPhysicalAddressListGet( IN  PAOS_CONTEXT pAosContext,IN  VOID * pKernelAddress,IN  ULONG Size,
+                                    IN  PNVA_AST* ppPhysicalAddressList,IN  ULONG * pNumberOfPhysicalAddressListEntries);
+VOID   NV_API_CALL AosMemoryPhysicalAddressListFree(IN  PAOS_CONTEXT pAosContext,IN  PNVA_AST pPhysicalAddressList);
+VOID   NV_API_CALL AosMemoryAllocPhysical(IN  PAOS_CONTEXT pAosContext,IN  ULONG Size,IN  NVA_U64 LowAddress,IN  NVA_U64 HighAddress,
+                                IN  VOID ** ppKernelAddress,IN  VOID ** ppUserAddress,IN  PNVA_AST* ppPhysicalAddressList,
+                                IN  PULONG pNumberOfPhysicalAddressListEntries,IN MEMORY_CACHING_TYPE CacheType);
+VOID   NV_API_CALL AosMemoryFreePhysical(IN  PAOS_CONTEXT pAosContext,IN  VOID * pKernelAddress,
+                                IN ULONG CacheType,IN  PNVA_AST pPhysicalAddressList);
+VOID   NV_API_CALL AosVmAllocPhysical(IN  ULONG Size, IN  VOID ** ppKernelAddress, IN  PNVA_AST* ppPhysicalAddressList,
+									  IN  PULONG pNumberOfPhysicalAddressListEntries);
+VOID   NV_API_CALL AosVmFreePhysical(IN  VOID * pKernelAddress, IN  PNVA_AST pPhysicalAddressList);
+
+
+unsigned char   NV_API_CALL AosPeek8(IN  PAOS_CONTEXT pAosContext,IN  VOID * pAddr);
+unsigned short  NV_API_CALL AosPeek16(IN PAOS_CONTEXT pAosContext,IN  VOID * pAddr);
+unsigned int    NV_API_CALL AosPeek32(IN PAOS_CONTEXT pAosContext,IN  VOID * pAddr);
+
+VOID  NV_API_CALL AosPoke8(IN  PAOS_CONTEXT pAosContext,IN  VOID * pAddr,IN  unsigned char Value);
+VOID  NV_API_CALL AosPoke16(IN PAOS_CONTEXT pAosContext,IN  VOID * pAddr,IN  unsigned short Value);
+VOID  NV_API_CALL AosPoke32(IN PAOS_CONTEXT pAosContext,IN  VOID * pAddr,IN  ULONG Value);
+
+VOID  NV_API_CALL AosReadPciConfig(IN  VOID * pDevice,IN ULONG *pValue, IN ULONG uRegIndex, IN ULONG uLength);
+VOID  NV_API_CALL AosWritePciConfig(IN VOID * pDevice,IN ULONG Value,   IN ULONG uRegIndex, IN ULONG uLength);
+VOID  NV_API_CALL AosSetPciDevice(IN   VOID * pAciDev,IN VOID * pApuDev);
+VOID  NV_API_CALL AosResetPciDevice(IN VOID);
+
+VOID  NV_API_CALL AosSetApuResources(IN  DEVICE_RESOURCES* device);
+VOID  NV_API_CALL AosGetApuResources(IN  DEVICE_RESOURCES* device);
+VOID  NV_API_CALL AosResetApuResources(IN VOID);
+
+unsigned long NV_API_CALL AosMapLinearAddress(VOID *pPhys, ULONG uSize, VOID**ppLinear);
+VOID  NV_API_CALL AosUnmapLinearAddress(VOID *pLinear);
+
+VOID NV_API_CALL AosDebugPrint(IN  char* Format, ...);
+int  NV_API_CALL AosSprintf(IN char *string,IN const char *format, ...);
+
+/****************************************
+*    AOS TIMER ROUTINES
+*****************************************/
+unsigned long NV_API_CALL AosTimerCreate(IN  PAOS_CONTEXT pAosContext,IN  VOID * pContext,IN  PAOS_TIMER_CALLBACK pCallback,IN  PNVA_TIMER* ppTimer);
+VOID   NV_API_CALL AosTimerFree(IN  PNVA_TIMER pTimer);
+BOOL   NV_API_CALL AosTimerSet(IN  PNVA_TIMER pTimer,IN  unsigned long DueTimeInMilliseconds,
+                    IN  unsigned long PeriodicTimeInMilliseconds,IN  BOOL ResetTimer);
+
+///////////////////////////////////
+//  Fpu Save & Restore function
+///////////////////////////////////
+VOID  NV_API_CALL AosFpuSave(int*);
+VOID  NV_API_CALL AosFpuRestore(int);
+VOID* NV_API_CALL AosGetLinearBase(VOID);
+VOID  NV_API_CALL AosSetVapu(unsigned int value);
+
+/////////////////////////////////////////
+//  String functions
+/////////////////////////////////////////
+char* NV_API_CALL AosStrcpy(char *dest, const char *src);
+int   NV_API_CALL AosStrlen(char *src);
+char* NV_API_CALL AosStrcat(char *dest, const char *src);
+int   NV_API_CALL AosStrcmp(const char *s1, const char *s2);
+int   NV_API_CALL AosMemCpyFromUsr(void *dest,const void* src,ULONG length);
+int   NV_API_CALL AosMemCpyToUsr(void *dest,const void* src,ULONG length);
+
+#ifdef __cplusplus
+};
+#endif
+
+#endif
+
+
diff -Naur NFORCE-Linux-x86-1.0-0310-pkg1.old/nvsound/main/nvavm.h NFORCE-Linux-x86-1.0-0310-pkg1/nvsound/main/nvavm.h
--- NFORCE-Linux-x86-1.0-0310-pkg1.old/nvsound/main/nvavm.h	2005-10-21 20:59:44.000000000 -0500
+++ NFORCE-Linux-x86-1.0-0310-pkg1/nvsound/main/nvavm.h	2008-08-14 10:13:48.000000000 -0500
@@ -202,18 +202,18 @@
  * 2.4 kernels, as it's possible some others may be missing this fix and
  * we'd prefer to be a little slower flushing caches than hanging the 
  * system. 2.6 kernels split the flushing out to a seperate call, 
- * global_flush_tlb(), so we rely on that.
+ * cpa_flush_all(), so we rely on that.
  */
 static void nv_flush_caches(void)
 {
-#if defined(KERNEL_2_4)
+/* #if defined(KERNEL_2_4)
 #ifdef CONFIG_SMP
     smp_call_function(cache_flush, NULL, 1, 1);
 #endif
     cache_flush(NULL);
 #else
-    global_flush_tlb();
-#endif
+    cpa_flush_all();
+#endif */ 
 }
 
 static inline int nv_calc_order(unsigned int size)
@@ -231,12 +231,12 @@
 static inline void NV_SET_PAGE_ATTRIB_UNCACHED(unsigned long physaddr)
     {
         struct page *page = virt_to_page(__va(physaddr));
-        change_page_attr(page, 1, PAGE_KERNEL_NOCACHE);
+        set_pages_uc(page, 1);
     }
 static inline void NV_SET_PAGE_ATTRIB_CACHED(unsigned long physaddr)
     {
         struct page *page = virt_to_page(__va(physaddr));
-        change_page_attr(page, 1, PAGE_KERNEL);
+        set_pages_wb(page, 1);
     }
 #else
 #define NV_SET_PAGE_ATTRIB_UNCACHED(page_list)
diff -Naur NFORCE-Linux-x86-1.0-0310-pkg1.old/nvsound/main/nvavm.h.orig NFORCE-Linux-x86-1.0-0310-pkg1/nvsound/main/nvavm.h.orig
--- NFORCE-Linux-x86-1.0-0310-pkg1.old/nvsound/main/nvavm.h.orig	1969-12-31 18:00:00.000000000 -0600
+++ NFORCE-Linux-x86-1.0-0310-pkg1/nvsound/main/nvavm.h.orig	2005-10-21 20:59:44.000000000 -0500
@@ -0,0 +1,247 @@
+/* 
+ *
+ * Copyright 2003-2004 by NVIDIA Corporation.  All rights reserved.  All
+ * information contained herein is proprietary and confidential to NVIDIA
+ * Corporation.  Any use, reproduction, or disclosure without the written
+ * permission of NVIDIA Corporation is prohibited.
+ * 
+ */
+
+/*
+* nvavm.h
+*
+* Definitions needed for the vm allocations
+*
+*/
+
+#ifndef _NVA_VM_H_
+#define _NVA_VM_H_
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 0)
+#  error This driver does not support pre-2.4 kernels!
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+#  define KERNEL_2_4
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+#  error This driver does not support 2.5 kernels!
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2, 7, 0)
+#  define KERNEL_2_6
+#else
+#  error This driver does not support development kernels!
+#endif
+
+#if defined (__i386__)
+#if defined (CONFIG_SMP) && !defined (__SMP__)
+#define __SMP__
+#endif
+
+#ifndef wbinvd
+#define wbinvd() __asm__ __volatile__("wbinvd" ::: "memory");
+#endif
+#endif /* defined(NVCPU_X86) */
+
+#ifdef EXPORT_NO_SYMBOLS
+/* don't clutter the kernel namespace with our symbols */
+EXPORT_NO_SYMBOLS;
+#endif
+
+#define CACHE_FLUSH()  asm volatile("wbinvd":::"memory")
+#define WRITE_COMBINE_FLUSH() asm volatile("sfence":::"memory")
+
+/* vmalloc_32 has to allocate memory under the 4GB mark suitable for
+ * DMA use with the hardware.  This has to be done differently for
+ * different platforms and kernel versions.
+ */
+#define NV_GET_FREE_PAGES(ptr, order) \
+    { \
+        (ptr) = __get_free_pages(NV_GFP_DMA32, order); \
+    }
+        
+#define NV_FREE_PAGES(ptr, order) \
+    { \
+        free_pages(ptr, order); \
+    }
+
+#define NV_GET_PAGE_STRUCT(phys_page) virt_to_page(__va(phys_page))
+#define NV_VMA_PGOFF(vma)             ((vma)->vm_pgoff)
+#define NV_VMA_SIZE(vma)              ((vma)->vm_end - (vma)->vm_start)
+#define NV_VMA_PRIVATE(vma)           ((vma)->vm_private_data)
+
+//
+// Needed definitions
+//
+#define NV_PGD_OFFSET(address, kernel, mm)              \
+   ({                                                   \
+        pgd_t *__pgd;                                   \
+        if (!kernel)                                    \
+            __pgd = pgd_offset(mm, address);            \
+        else                                            \
+            __pgd = pgd_offset_k(address);              \
+        __pgd;                                          \
+    })
+
+#define NV_PGD_PRESENT(pgd)                             \
+   ({                                                   \
+         if ((pgd != NULL) &&                           \
+             (pgd_bad(*pgd) || pgd_none(*pgd)))         \
+            /* static */ pgd = NULL;                    \
+         pgd != NULL;                                   \
+    })
+
+#if defined(pmd_offset_map)
+#define NV_PMD_OFFSET(address, pgd)                     \
+   ({                                                   \
+        pmd_t *__pmd;                                   \
+        __pmd = pmd_offset_map(pgd, address);           \
+   })
+#define NV_PMD_UNMAP(pmd) pmd_unmap(pmd);
+#else
+#if defined(PUD_SHIFT) /* 4-level pgtable */
+#define NV_PMD_OFFSET(address, pgd)                     \
+   ({                                                   \
+        pmd_t *__pmd = NULL;                            \
+        pud_t *__pud;                                   \
+        __pud = pud_offset(pgd, address);               \
+        if ((__pud != NULL) &&                          \
+            !(pud_bad(*__pud) || pud_none(*__pud)))     \
+            __pmd = pmd_offset(__pud, address);         \
+        __pmd;                                          \
+    })
+#else /* 3-level pgtable */
+#define NV_PMD_OFFSET(address, pgd)                     \
+   ({                                                   \
+        pmd_t *__pmd;                                   \
+        __pmd = pmd_offset(pgd, address);               \
+    })
+#endif
+#define NV_PMD_UNMAP(pmd)
+#endif
+
+#define NV_PMD_PRESENT(pmd)                             \
+   ({                                                   \
+        if ((pmd != NULL) &&                            \
+            (pmd_bad(*pmd) || pmd_none(*pmd)))          \
+        {                                               \
+            NV_PMD_UNMAP(pmd);                          \
+            pmd = NULL; /* mark invalid */              \
+        }                                               \
+        pmd != NULL;                                    \
+    })
+
+#if defined(pte_offset_atomic)
+#define NV_PTE_OFFSET(address, pmd)                     \
+   ({                                                   \
+        pte_t *__pte;                                   \
+        __pte = pte_offset_atomic(pmd, address);        \
+        NV_PMD_UNMAP(pmd); __pte;                       \
+    })
+#define NV_PTE_UNMAP(pte) pte_kunmap(pte);
+#elif defined(pte_offset)
+#define NV_PTE_OFFSET(address, pmd)                     \
+   ({                                                   \
+        pte_t *__pte;                                   \
+        __pte = pte_offset(pmd, address);               \
+        NV_PMD_UNMAP(pmd); __pte;                       \
+    })
+#define NV_PTE_UNMAP(pte)
+#else
+#define NV_PTE_OFFSET(address, pmd)                     \
+   ({                                                   \
+        pte_t *__pte;                                   \
+        __pte = pte_offset_map(pmd, address);           \
+        NV_PMD_UNMAP(pmd); __pte;                       \
+    })
+#define NV_PTE_UNMAP(pte) pte_unmap(pte);
+#endif
+
+#define NV_PTE_PRESENT(pte)                             \
+   ({                                                   \
+        if ((pte != NULL) && !pte_present(*pte))        \
+        {                                               \
+            NV_PTE_UNMAP(pte);                          \
+            pte = NULL; /* mark invalid */              \
+        }                                               \
+        pte != NULL;                                    \
+    })
+
+#define NV_PTE_VALUE(pte)                               \
+   ({                                                   \
+        unsigned long __pte_value = pte_val(*pte);      \
+        NV_PTE_UNMAP(pte);                              \
+        __pte_value;                                    \
+    })
+
+
+#define NV_PAGE_ALIGN(addr)             ( ((addr) + PAGE_SIZE - 1) / PAGE_SIZE)
+#define NV_MASK_OFFSET(addr)            ( (addr) & (PAGE_SIZE - 1) )
+
+
+
+
+/* cache flushing
+ * when allocating new pages, we convert the kernel mapping from cached to
+ * uncached to avoid cache aliasing. one problem with this is that cpus can 
+ * still contain data cached from these pages, in addition to stale ptes that
+ * are cached and think the pages are still cached. normally, the cpu's self
+ * snoop (SS) capability would catch this between cpus, but if the pages are
+ * mapped through the agp aperture, SS is not capable of detecting these
+ * conflicts. we try to rely on the kernel's provided interfaces when possible,
+ * but need additional flushing on earlier kernels.
+ */
+#if defined(KERNEL_2_4)
+/* wrap CACHE_FLUSH so we can pass it to smp_call_function */
+static void cache_flush(void *p)
+{
+    CACHE_FLUSH();
+}
+#endif
+
+/*
+ * 2.4 kernels handle flushing in the change_page_attr() call, but kernels 
+ * earlier than 2.4.27 don't flush on cpus that support Self Snoop, so we
+ * manually flush on these kernels (actually, we go ahead and flush on all
+ * 2.4 kernels, as it's possible some others may be missing this fix and
+ * we'd prefer to be a little slower flushing caches than hanging the 
+ * system. 2.6 kernels split the flushing out to a seperate call, 
+ * global_flush_tlb(), so we rely on that.
+ */
+static void nv_flush_caches(void)
+{
+#if defined(KERNEL_2_4)
+#ifdef CONFIG_SMP
+    smp_call_function(cache_flush, NULL, 1, 1);
+#endif
+    cache_flush(NULL);
+#else
+    global_flush_tlb();
+#endif
+}
+
+static inline int nv_calc_order(unsigned int size)
+{
+    int order = 0;
+    while ( ((1 << order) * PAGE_SIZE) < (size))
+    {
+        order++;
+    }
+    return order;
+}
+
+
+#if defined(NV_CHANGE_PAGE_ATTR_PRESENT) 
+static inline void NV_SET_PAGE_ATTRIB_UNCACHED(unsigned long physaddr)
+    {
+        struct page *page = virt_to_page(__va(physaddr));
+        change_page_attr(page, 1, PAGE_KERNEL_NOCACHE);
+    }
+static inline void NV_SET_PAGE_ATTRIB_CACHED(unsigned long physaddr)
+    {
+        struct page *page = virt_to_page(__va(physaddr));
+        change_page_attr(page, 1, PAGE_KERNEL);
+    }
+#else
+#define NV_SET_PAGE_ATTRIB_UNCACHED(page_list)
+#define NV_SET_PAGE_ATTRIB_CACHED(page_list)
+#endif
+
+#endif  /* _NVA_VM_H_ */
+
diff -Naur NFORCE-Linux-x86-1.0-0310-pkg1.old/nvsound/main/nvmain.c NFORCE-Linux-x86-1.0-0310-pkg1/nvsound/main/nvmain.c
--- NFORCE-Linux-x86-1.0-0310-pkg1.old/nvsound/main/nvmain.c	2005-10-21 20:59:44.000000000 -0500
+++ NFORCE-Linux-x86-1.0-0310-pkg1/nvsound/main/nvmain.c	2008-08-14 10:13:48.000000000 -0500
@@ -2074,7 +2074,7 @@
            card_names[pci_id->driver_data], devs->hwbase->apubase,devs->hwbase->apuirq);
 
         
-        if(request_irq(devs->hwbase->apuirq,&Nvapu_interrupt, SA_SHIRQ, card_names[pci_id->driver_data], devs)) {
+        if(request_irq(devs->hwbase->apuirq,&Nvapu_interrupt, IRQF_SHARED, card_names[pci_id->driver_data], devs)) {
             printk(KERN_ERR "Nvsound:  IRQ in use \n");
             ret = -EBUSY;
             NvRelease_Resources(devs);
@@ -2162,7 +2162,7 @@
         }
 
         // ISR should be register after the initialization
-        if(request_irq(devs->hwbase->aciirq,&Nvaci_interrupt, SA_SHIRQ, card_names[pci_id->driver_data], devs)) {
+        if(request_irq(devs->hwbase->aciirq,&Nvaci_interrupt, IRQF_SHARED, card_names[pci_id->driver_data], devs)) {
             printk(KERN_ERR "Nvsound: IRQ in use \n");
             NvRelease_Resources(devs);
             ret = -EBUSY;
@@ -2188,7 +2188,7 @@
     }
 }
 
-MODULE_PARM(vapu_enable, "i");
+module_param(vapu_enable, int, 0444);
 #define NVAUDIO_MODULE_NAME "nforce_audio"
 static struct pci_driver Nvaudio_pci_driver = {
     name: NVAUDIO_MODULE_NAME,
@@ -2205,7 +2205,7 @@
     int ret = 0;
     printk(KERN_INFO "Nvsound: Nvidia Audio Init Module, " __TIME__ " " __DATE__ " version %s \n",
            DRIVERVER);
-    ret = pci_module_init(&Nvaudio_pci_driver);
+    ret = ret = pci_register_driver(&Nvaudio_pci_driver);
     return ret;
 }
 
diff -Naur NFORCE-Linux-x86-1.0-0310-pkg1.old/nvsound/main/nvmain.c.orig NFORCE-Linux-x86-1.0-0310-pkg1/nvsound/main/nvmain.c.orig
--- NFORCE-Linux-x86-1.0-0310-pkg1.old/nvsound/main/nvmain.c.orig	1969-12-31 18:00:00.000000000 -0600
+++ NFORCE-Linux-x86-1.0-0310-pkg1/nvsound/main/nvmain.c.orig	2005-10-21 20:59:44.000000000 -0500
@@ -0,0 +1,2221 @@
+
+/****************************************************************** \
+|*                                                                 *|
+|*                                                                 *|
+|*  (c) NVIDIA Corporation. All rights reserved                    *| 
+|*                                                                 *|
+|*  THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND            *|
+|*  CONFIDENTIAL                                                   *|
+|*  TO NVIDIA, CORPORATION. USE, REPORDUCTION OR DISCLOSURE TO ANY *|
+|*  THIRD PARTY IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA CORP. *|
+|*                                                                 *|
+|*  THE INFORMATION CONTAINED HEREIN IS PROVIDED "AS IS" WITHOUT   *|
+|*  EXPRESS OR IMPLIED WARRANTY OF ANY KIND, INCLUDING ALL IMPLIED *|
+|*  WARRANTIES OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS    *|
+|*  FOR A PARTICULAR PURPOSE.                                      *|
+|*                                                                 *|
+********************************************************************/
+/*******************************************************************
+*
+*  nvmain.c
+*
+*  Descripion  - Main code for the driver
+*
+********************************************************************
+*/
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include "nvhw.h"
+#include "nvapucalls.h"
+
+#define PRINT_IOCTL 0
+#define ENABLE_MONO 1
+
+#ifndef PCI_DEVICE_ID_NVIDIA_MCP1_AUDIO
+#define PCI_DEVICE_ID_NVIDIA_MCP1_AUDIO 0x01b1
+#endif
+
+#ifndef PCI_DEVICE_ID_NVIDIA_MCP2_AUDIO
+#define PCI_DEVICE_ID_NVIDIA_MCP2_AUDIO 0x006a
+#endif
+
+#ifndef PCI_DEVICE_ID_NVIDIA_MCP2S_AUDIO
+#define PCI_DEVICE_ID_NVIDIA_MCP2S_AUDIO 0x008a
+#endif
+
+#ifndef PCI_DEVICE_ID_NVIDIA_MCP3_AUDIO
+#define PCI_DEVICE_ID_NVIDIA_MCP3_AUDIO 0x00da
+#endif
+
+#ifndef PCI_DEVICE_ID_NVIDIA_CK8S_AUDIO
+#define PCI_DEVICE_ID_NVIDIA_CK8S_AUDIO 0x00ea
+#endif
+
+#ifndef PCI_DEVICE_ID_NVIDIA_CK804_AUDIO
+#define PCI_DEVICE_ID_NVIDIA_CK804_AUDIO 0x0059
+#endif
+
+#ifndef PCI_DEVICE_ID_NVIDIA_MCP04_AUDIO
+#define PCI_DEVICE_ID_NVIDIA_MCP04_AUDIO 0x003a
+#endif
+
+#ifndef PCI_DEVICE_ID_NVIDIA_MCP51_AUDIO
+#define PCI_DEVICE_ID_NVIDIA_MCP51_AUDIO 0x026B
+#endif
+
+#ifndef PCI_DEVICE_ID_NVIDIA_MCP2_CONTROLLER
+#define PCI_DEVICE_ID_NVIDIA_MCP2_CONTROLLER 0x006b
+#endif
+
+#ifndef PCI_DEVICE_ID_NVIDIA_MCP1_CONTROLLER
+#define PCI_DEVICE_ID_NVIDIA_MCP1_CONTROLLER 0x01b0
+#endif
+enum {
+    NVIDIA_NFORCE2_CONTROLLER=0,
+    NVIDIA_NFORCE1_CONTROLLER,
+    NVIDIA_NFORCE1,
+    NVIDIA_NFORCE2,
+    NVIDIA_NFORCE3,
+    NVIDIA_MCP2S,
+    NVIDIA_CK8S,
+    NVIDIA_CK804,
+    NVIDIA_MCP04,
+    NVIDIA_MCP51
+};
+static char * card_names[] = {
+    "NVIDIA nForce2 Controller",
+    "NVIDIA nForce1 Controller",
+    "NVIDIA nForce1 Audio",
+    "NVIDIA nForce2 Audio",
+    "NVIDIA Hammer Audio",
+    "NVIDIA MCP2S Audio",
+    "NVIDIA CK8S Audio",
+    "NVIDIA CK804 Audio",
+    "NVIDIA MCP04 Audio",
+    "NVIDIA MCP51 Audio"
+};
+static struct pci_device_id Nvaudio_pci_tbl[] = {
+    {PCI_VENDOR_ID_NVIDIA,PCI_DEVICE_ID_NVIDIA_MCP2_CONTROLLER,
+     PCI_ANY_ID, PCI_ANY_ID, 0, 0, NVIDIA_NFORCE2_CONTROLLER},
+    {PCI_VENDOR_ID_NVIDIA,PCI_DEVICE_ID_NVIDIA_MCP1_CONTROLLER,
+     PCI_ANY_ID, PCI_ANY_ID, 0, 0, NVIDIA_NFORCE1_CONTROLLER},
+    {PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_MCP1_AUDIO,
+     PCI_ANY_ID, PCI_ANY_ID, 0, 0, NVIDIA_NFORCE1},
+    {PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_MCP2_AUDIO,
+     PCI_ANY_ID, PCI_ANY_ID, 0, 0, NVIDIA_NFORCE2},
+    {PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_MCP3_AUDIO,
+     PCI_ANY_ID, PCI_ANY_ID, 0, 0, NVIDIA_NFORCE3},
+    {PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_MCP2S_AUDIO,
+     PCI_ANY_ID, PCI_ANY_ID, 0, 0, NVIDIA_MCP2S},
+    {PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_CK8S_AUDIO,
+     PCI_ANY_ID, PCI_ANY_ID, 0, 0, NVIDIA_CK8S},
+    {PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_CK804_AUDIO,
+     PCI_ANY_ID, PCI_ANY_ID, 0, 0, NVIDIA_CK804},
+    {PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_MCP04_AUDIO,
+     PCI_ANY_ID, PCI_ANY_ID, 0, 0, NVIDIA_MCP04},
+     {PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_MCP51_AUDIO,
+     PCI_ANY_ID, PCI_ANY_ID, 0, 0, NVIDIA_MCP51},
+    {0,}
+};
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,10)
+MODULE_LICENSE("NVIDIA");
+#endif
+
+MODULE_DEVICE_TABLE(pci, Nvaudio_pci_tbl);
+static Nvaudio_card *devs = NULL;
+static unsigned int vapu_enable = 0;
+
+static int Nvadd_wave_device(Nvaudio_card *card, struct file *file, int dev_type);
+static int alloc_frags(Nvaudio_card *card, Nvaudio_stream *stream, unsigned long count);
+static int dealloc_frags(Nvaudio_stream *nvstream, void *pDevice);
+static void Nvfree_wave_device(Nvaudio_card *card, Nvaudio_wavedev *nvwavdev);
+static void Nvremove_wave_device(Nvaudio_card *card, Nvaudio_wavedev *nvwavdev);
+static Nvaudio_wavedev* Nvfind_wave_device(Nvaudio_card *card, struct file *file);
+static void Nvstop_wave(Nvaudio_card *card, Nvaudio_stream *nvstream, int type);
+static unsigned long Nvfill_mem(Nvaudio_card *card, Nvaudio_stream *nvstream, const char *mem, unsigned long size);
+static unsigned long Nvget_mem(Nvaudio_card *card, Nvaudio_stream *nvstream, char *mem, unsigned long size);
+static void drain_dac(Nvaudio_card *card, Nvaudio_wavedev *nvwavdev, int nonblock);
+static int Nvaudio_release(struct inode *inode, struct file *file);
+static int Nvaudio_open(struct inode *inode, struct file *file);
+static int Nvfree_reopenStream(Nvaudio_wavedev *nvwavdev, struct file *file);
+
+#define INT_MASK  0xAF7
+
+void playback_tasklet(unsigned long cardinfo);
+void record_tasklet(unsigned long cardinfo);
+DECLARE_TASKLET(playbacktask,playback_tasklet,0);
+DECLARE_TASKLET(recordtask,record_tasklet,0);
+
+////////////////////////////////////////////////////////////////////////
+// APU ISR FUNCTION which in turn schedule a tasklet 
+////////////////////////////////////////////////////////////////////////
+static irqreturn_t Nvapu_interrupt(int irq, void* dev_id, struct pt_regs *regs)
+{
+    int status = 0;
+    Nvaudio_card *card  = (Nvaudio_card *)dev_id;
+
+    spin_lock(&card->play_lock);
+    status = Nv_ApuISR(); 
+    
+    if(!status){
+        tasklet_schedule(&playbacktask);
+    }else {
+        // not our irq
+        spin_unlock(&card->play_lock);    
+        return IRQ_NONE;
+    }
+
+    spin_unlock(&card->play_lock);    
+    return IRQ_HANDLED;   
+}
+
+////////////////////////////////////////////////////////////////////////
+// APU ISR tasklet -  function to verify all running playback streams
+////////////////////////////////////////////////////////////////////////
+void playback_tasklet(unsigned long cardinfo)
+{
+    mem_buf_t *cur = NULL;
+    unsigned long flags = 0;
+    unsigned long count = 0, remaining = 0;
+    long long curposn = 0;
+    Nvaudio_stream *nvstream = NULL;
+    Nvaudio_wavedev *nvwavdev = NULL;
+    
+    spin_lock_irqsave(&devs->list_lock,flags);
+    nvwavdev = devs->wave_head;
+    spin_unlock_irqrestore(&devs->list_lock,flags);
+
+//  if(vapu_enable)
+        Nv_VapuDpc();
+    while(nvwavdev) {
+        if(nvwavdev->playback_stream.enable || nvwavdev->playback_stream.mapped ) {
+            nvstream = &nvwavdev->playback_stream;
+            curposn = Nv_getposition(nvstream->wavestream);
+            /*if((!curposn) && (nvstream->total_played < nvstream->total_sent)){
+                nvstream->total_played = nvstream->total_sent;
+            }   
+            if(!curposn){
+                wake_up_interruptible(&nvstream->wait);
+            }*/
+            if(curposn > nvstream->lastposition) {
+                count = (unsigned long)(curposn - nvstream->lastposition);
+                nvstream->total_played +=count;
+                nvstream->lastposition = curposn;
+            }else{
+                wake_up_interruptible(&nvstream->wait);
+            }
+
+            while(count > 0){
+                cur = (mem_buf_t *) &(nvstream->buf[nvstream->drain_index]);
+                remaining = cur->count - cur->xfer;
+                // assert if page not in use - starving case
+                if(!cur->in_use) {
+                    count = 0;
+                    break;
+                }
+                if(count < remaining){
+                    cur->xfer += count;
+                    count = 0;
+                }else {
+                    nvstream->drain_index = (nvstream->drain_index + 1) % nvstream->num_frags;
+                    if(nvstream->mapped){
+                        cur->xfer = 0;
+                        Nv_passdown(nvstream->wavestream,cur->page,cur->count,nvstream->drain_index,FALSE);
+                    }else{
+                        cur->xfer = cur->count;
+                        cur->count = 0;
+                        cur->in_use = FALSE;
+                        wake_up_interruptible(&nvstream->wait);
+                    }
+                    count -= remaining;
+                }
+            }
+        }   
+        spin_lock_irqsave(&devs->list_lock,flags);
+        nvwavdev = nvwavdev->next;
+        spin_unlock_irqrestore(&devs->list_lock,flags);
+    }   
+}
+
+////////////////////////////////////////////////////////////////////////
+// ACI ISR - right now it doesnot get hit as we didnot request interrupt
+// on buffer completion
+////////////////////////////////////////////////////////////////////////
+static irqreturn_t Nvaci_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+    int status = 0;
+    u32 globstat = 0;
+    Nvaudio_card *card   = (Nvaudio_card *)dev_id;
+    
+    //spin_lock(&card->play_lock);
+    spin_lock(&card->rec_lock);
+    globstat = inl(card->hwbase->acibase + 0x30);
+
+    if(!(globstat & INT_MASK)) {
+        spin_unlock(&card->rec_lock);
+      //  spin_unlock(&card->play_lock);
+        return IRQ_NONE;
+    }
+   
+    status = Nv_AciISR();
+    if(!status) {
+        // need this to run in case of spdif only - with or without apu
+        if( (card->hwbase->acipresent) && ( (!(card->hwbase->apupresent)) || card->ac3_in_use ) ){ 
+            tasklet_schedule(&playbacktask);
+        }
+        tasklet_schedule(&recordtask); 
+    }
+    spin_unlock(&card->rec_lock);
+    //spin_unlock(&card->play_lock);
+    return IRQ_HANDLED;   
+}
+
+////////////////////////////////////////////////////////////////////////
+// ACI ISR tasklet -  function to verify running record
+////////////////////////////////////////////////////////////////////////
+void record_tasklet(unsigned long cardinfo)
+{
+    mem_buf_t *cur = NULL;
+    unsigned long flags = 0;
+    unsigned long count = 0, remaining = 0;
+    long long  curposn = 0;
+    Nvaudio_stream *nvstream = NULL;
+    Nvaudio_wavedev *nvwavdev = NULL;
+    spin_lock_irqsave(&devs->list_lock,flags);
+    nvwavdev = devs->wave_head;
+    spin_unlock_irqrestore(&devs->list_lock,flags);
+    while(nvwavdev) {
+        if(nvwavdev->record_stream.enable || nvwavdev->record_stream.mapped ) {
+            nvstream = &nvwavdev->record_stream;
+            curposn = Nv_getposition(nvstream->wavestream);
+
+            if(curposn > nvstream->lastposition) {
+                count = (unsigned long)(curposn - nvstream->lastposition);
+                nvstream->total_played +=count;
+                nvstream->lastposition = curposn;
+            }else {
+                wake_up_interruptible(&nvstream->wait);
+            }
+
+            while(count > 0){
+                cur = &(nvstream->buf[nvstream->fill_index]);
+                remaining = cur->count - cur->xfer;
+                // assert if page not in use - starving case
+                if(!cur->in_use) {
+                    count = 0;
+                    break;
+                }
+                if(count < remaining){
+                    cur->xfer += count;
+                    count = 0;
+                }else {
+                    nvstream->fill_index = (nvstream->fill_index + 1) % nvstream->num_frags;
+                    if(nvstream->mapped){
+                        cur->xfer = 0;
+                        Nv_passdown(nvstream->wavestream,cur->page,cur->count,nvstream->fill_index,FALSE);
+                    }else{
+                        cur->xfer = cur->count;
+                        cur->count = 0;
+                        cur->in_use = FALSE;
+                        wake_up_interruptible(&nvstream->wait);
+                    }
+                    count -= remaining;
+                }
+            }
+        }   
+        spin_lock_irqsave(&devs->list_lock,flags);
+        nvwavdev = nvwavdev->next;
+        spin_unlock_irqrestore(&devs->list_lock,flags);
+    }   
+}
+////////////////////////////////////////////////////////////////////////
+// Deallocate the dma buffer for each stream
+////////////////////////////////////////////////////////////////////////
+static int dealloc_frags(Nvaudio_stream *nvstream, void *pDevice)
+{
+    struct page *page = NULL, *pend = NULL;
+    if (nvstream->vir_dmabuf) {
+        // undo marking the pages as reserved 
+        pend = virt_to_page((u8 *)nvstream->vir_dmabuf + ((PAGE_SIZE << nvstream->buf_order) - 1));
+        for (page = virt_to_page(nvstream->vir_dmabuf); page <= pend; page++) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+            mem_map_unreserve(page);
+#else
+            ClearPageReserved(page);
+#endif
+        }
+
+        if(pDevice) {
+            pci_free_consistent(pDevice, PAGE_SIZE << nvstream->buf_order,
+                    nvstream->vir_dmabuf, nvstream->dma_handle);
+        }
+    }
+    return 0;
+}
+////////////////////////////////////////////////////////////////////////
+// Allocate the dma buffer for each stream
+////////////////////////////////////////////////////////////////////////
+static int alloc_frags(Nvaudio_card * card, Nvaudio_stream *stream, unsigned long count)
+{
+    struct page *page = NULL, *pend = NULL;
+    unsigned long page_addr = 0;
+    int i = 0;
+    void *pDevice = NULL;
+    unsigned long order = 0;
+    order = NV_DEFAULTORDER;
+
+    // Find which device is present or not first
+    if(card->hwbase->apupresent) {
+        pDevice = card->hwbase->pApu_dev;
+    }
+    else { // assume aci is present
+        pDevice = card->hwbase->pAci_dev;
+    }
+    if(!pDevice) { return -EBUSY;}
+
+    stream->vir_dmabuf = pci_alloc_consistent(pDevice,
+                       PAGE_SIZE << order,
+                       &stream->dma_handle);
+    if(!stream->vir_dmabuf){
+        printk("Nvsound: Unable to allocate the dmabuffer for the stream \n");
+        return -ENOMEM;
+    }
+
+    stream->buf_order = order;
+
+    // now mark the pages as reserved;
+    // otherwise remap_page_range doesn't do what we want 
+
+    pend = virt_to_page((u8 *)stream->vir_dmabuf + ((PAGE_SIZE << order) - 1));
+    for (page = virt_to_page(stream->vir_dmabuf); page <= pend; page++) {
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+        mem_map_reserve(page);
+#else
+        SetPageReserved(page);
+#endif
+
+    }
+    page_addr = (unsigned long) stream->vir_dmabuf;
+    for(i=0; i < count; i++) {
+        stream->buf[i].page   = (void *)page_addr;
+        stream->buf[i].in_use = FALSE;
+        stream->buf[i].count  = 0;
+        page_addr += stream->frag_size;
+    }
+    
+    return 0;
+}
+
+////////////////////////////////////////////////////////////////////////
+// Free a wave device - free newstream created and deallocate the dma for
+// hardware to access
+////////////////////////////////////////////////////////////////////////
+static void Nvfree_wave_device(Nvaudio_card *card, Nvaudio_wavedev *nvwavdev)
+{
+    unsigned long flags = 0;
+    void* pDevice       = 0;
+    // Find which device is present or not first
+    if(card->hwbase->apupresent) {
+        pDevice = card->hwbase->pApu_dev;
+    }
+    else { // assume aci is present
+        pDevice = card->hwbase->pAci_dev;
+    }
+    
+    if (nvwavdev->playback_stream.wavestream) {
+        if(!nvwavdev->playback_stream.verifyac3)
+            spin_lock_irqsave(&card->play_lock,flags);
+        Nv_FreeNewstream(nvwavdev->playback_stream.wavestream);
+        if(!nvwavdev->playback_stream.verifyac3)
+            spin_unlock_irqrestore(&card->play_lock,flags);
+        if(nvwavdev->playback_stream.verifyac3) {
+            nvwavdev->playback_stream.verifyac3 = 0;
+            card->ac3_in_use = 0;
+        }
+    }
+
+    if (nvwavdev->record_stream.wavestream) {
+        spin_lock_irqsave(&card->rec_lock, flags);
+        Nv_FreeNewstream(nvwavdev->record_stream.wavestream);
+        spin_unlock_irqrestore(&card->rec_lock, flags);
+    }
+    
+    // dealloc frags for playback
+    dealloc_frags(&nvwavdev->playback_stream,pDevice);
+    
+    // dealloc frags for record
+    dealloc_frags(&nvwavdev->record_stream,pDevice);
+    
+    kfree(nvwavdev);
+    return;
+}
+////////////////////////////////////////////////////////////////////////
+// ADD a wave device - create a newstream and allocate the dma for
+// hardware to access
+////////////////////////////////////////////////////////////////////////
+static int Nvadd_wave_device(Nvaudio_card *card, struct file *file, int dev_type)
+{
+    unsigned long flags = 0;
+    int status          = 0;
+    int is_apupresent   = 0;
+    Nvaudio_wavedev *nvwavdev;
+    int is_playback     =   file->f_mode & FMODE_WRITE;
+    int is_record       =   file->f_mode & FMODE_READ;
+    
+    if(card->hwbase->apupresent) is_apupresent = 1;
+
+    // allow only one rec - This cause issue with Quake and other app using record section
+    //if(is_record && card->rec_in_use)
+    //     return -EBUSY;
+
+    nvwavdev = (Nvaudio_wavedev *)kmalloc(sizeof(Nvaudio_wavedev),GFP_KERNEL);
+    if(!nvwavdev) {
+        return -ENOMEM;
+    }
+    memset(nvwavdev,0,sizeof(Nvaudio_wavedev));
+
+    //Set default data format
+    nvwavdev->playback_stream.fmt.dwSampleRate   = DEFAULT_SAMPLERATE;
+    nvwavdev->playback_stream.fmt.wChannels      = 2; //stereo
+    nvwavdev->playback_stream.fmt.wBitsPerSample = 16; 
+    nvwavdev->playback_stream.fmt.wformat        = AFMT_S16_LE;
+    init_waitqueue_head(&nvwavdev->playback_stream.wait);
+
+    nvwavdev->record_stream.fmt.dwSampleRate   = DEFAULT_SAMPLERATE;
+    nvwavdev->record_stream.fmt.wChannels      = 2; //stereo
+    nvwavdev->record_stream.fmt.wBitsPerSample = 16; 
+    nvwavdev->record_stream.fmt.wformat        = AFMT_S16_LE;
+    nvwavdev->record_stream.Channels           = 2;
+    init_waitqueue_head(&nvwavdev->record_stream.wait);
+
+    // fixed size buffer are provided - need to verify whether it
+    // affect any apps
+    nvwavdev->playback_stream.frag_size  = NVDEFAULT_FRAGSIZE;
+    nvwavdev->playback_stream.num_frags  = NVDEFAULT_FRAGS;
+    nvwavdev->record_stream.frag_size    = NVDEFAULT_FRAGSIZE;
+    nvwavdev->record_stream.num_frags    = NVDEFAULT_FRAGS;
+
+    nvwavdev->fp                         = file;
+
+    if((is_record) && (!card->rec_in_use)) {
+        if(alloc_frags(card,&(nvwavdev->record_stream),nvwavdev->record_stream.num_frags)) {
+            printk("Nvsound: Unable to allocate the pages for the record stream \n");
+            Nvfree_wave_device(card,nvwavdev);
+            return -ENOMEM;
+        }
+        status = Nv_CreateNewstream(&(nvwavdev->record_stream.fmt),NVDIRREC,&(nvwavdev->record_stream.wavestream),is_apupresent);
+        if(status) {
+            printk("Nvsound: Unable to Create a NewStream for recording \n");
+            Nvfree_wave_device(card,nvwavdev);
+            return -ENOMEM;
+        }
+        card->rec_in_use = TRUE;
+    }
+
+    if(is_playback) {
+        if(alloc_frags(card,&(nvwavdev->playback_stream),nvwavdev->playback_stream.num_frags)) {
+            printk("Nvsound: Unable to allocate the pages for the playback stream \n");
+            Nvfree_wave_device(card,nvwavdev);
+            return -ENOMEM;
+        }
+        status = Nv_CreateNewstream(&(nvwavdev->playback_stream.fmt),NVDIRPLAY,&(nvwavdev->playback_stream.wavestream),is_apupresent);
+        if(status) {
+            printk("Nvsound: Unable to Create a NewStream for apu \n");
+            Nvfree_wave_device(card,nvwavdev);
+            return -ENOMEM;
+        }
+    }
+
+    spin_lock_irqsave(&card->list_lock,flags);
+    // link the device to the list
+    if(card->wave_head == NULL) {
+        card->wave_head = nvwavdev;
+        card->wave_tail = nvwavdev;
+    }
+    else {
+        card->wave_tail->next = nvwavdev;
+        nvwavdev->prev        = card->wave_tail;
+        card->wave_tail       = nvwavdev;
+    }
+    spin_unlock_irqrestore(&card->list_lock,flags);
+    return 0;
+}
+
+////////////////////////////////////////////////////////////////////////
+// Function to find the wave device from the device list
+////////////////////////////////////////////////////////////////////////
+static Nvaudio_wavedev* Nvfind_wave_device(Nvaudio_card *card, struct file *file)
+{
+    unsigned long flags = 0;
+    Nvaudio_wavedev *nvwavdev = NULL;
+
+    // could use reader/writer spinlocks 
+    spin_lock_irqsave(&card->list_lock,flags);
+    
+    nvwavdev = card->wave_head;
+
+    while (nvwavdev) {
+        if (nvwavdev->fp == file)
+            break;
+        nvwavdev = nvwavdev->next;
+    }
+    spin_unlock_irqrestore(&card->list_lock,flags);
+    
+    return nvwavdev;
+}
+
+////////////////////////////////////////////////////////////////////////
+// Function to remove a wave device from the list
+////////////////////////////////////////////////////////////////////////
+static void Nvremove_wave_device(Nvaudio_card *card, Nvaudio_wavedev *nvwavdev)
+{
+    unsigned long flags = 0;
+    spin_lock_irqsave(&card->list_lock,flags);
+    // unlink the wave device 
+    if(nvwavdev == card->wave_head) {
+        card->wave_head = nvwavdev->next;
+        if(card->wave_head)
+            card->wave_head->prev = NULL;
+    } else {
+        nvwavdev->prev->next = nvwavdev->next;
+        if(nvwavdev->next)
+            nvwavdev->next->prev = nvwavdev->prev;
+        else
+            card->wave_tail = nvwavdev->prev;
+    }
+    spin_unlock_irqrestore(&card->list_lock,flags);
+    Nvfree_wave_device(card, nvwavdev);
+}
+
+////////////////////////////////////////////////////////////////////////
+//   Nvaudio_read which helps to pass the recorded data from hw to user.
+//  It is filled by the dma machine and drained by this loop. 
+////////////////////////////////////////////////////////////////////////
+static ssize_t Nvaudio_read(struct file *file, char *buffer, size_t count, loff_t *ppos)
+{
+    size_t xfer =0, received = 0;
+    Nvaudio_wavedev *nvwavdev = NULL;
+    Nvaudio_stream  *nvstream = NULL;
+    unsigned long flags = 0;
+    Nvaudio_card *card = (Nvaudio_card *)file->private_data;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+    DECLARE_WAITQUEUE(waita,current);
+#else
+    DEFINE_WAIT(waita);
+#endif
+   
+    nvwavdev = Nvfind_wave_device(card,file);
+    if(!nvwavdev) {
+        printk("Nvsound: Unable to find any wave device \n");
+        return -ENXIO;
+    }
+
+    nvstream = &nvwavdev->record_stream;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,8)
+    if( ppos != &file->f_pos)
+        return -ESPIPE;
+#endif
+
+    if(!nvstream->wavestream) {
+        // Hack Team Speak to sound - if rec already in use
+        return count;
+    }
+    if(nvstream->mapped)
+        return -ENXIO;
+    
+    if (!access_ok(VERIFY_WRITE, buffer, count))
+        return -EFAULT;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+    add_wait_queue(&nvstream->wait,&waita);
+#endif
+    
+    while(received < count) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+        set_current_state(TASK_INTERRUPTIBLE);
+#else
+        prepare_to_wait(&nvstream->wait,&waita,TASK_INTERRUPTIBLE);
+#endif
+        //if not enabled - Nvget_mem will add first buffers, else
+        //copy the completed buffers to user space and queue if not
+        //filled completely
+        xfer = Nvget_mem(card,nvstream,buffer+received,(count-received));
+        received += xfer;
+        
+        if(!nvstream->enable) {
+            spin_lock_irqsave(&card->rec_lock,flags);
+            Nv_start(nvstream->wavestream);
+            nvstream->enable = TRUE;
+            spin_unlock_irqrestore(&card->rec_lock,flags);
+        }
+        if(received < count) {
+            if(file->f_flags & O_NONBLOCK) {
+                received = (received)? (ssize_t)received: -EAGAIN;
+                goto recdone;
+            }
+
+            //interruptible_sleep_on(&nvstream->wait);
+            schedule_timeout(15);
+            if(signal_pending(current)) {
+                received = (received)? (ssize_t) received: -ERESTARTSYS;
+                goto recdone;
+            }
+            continue;
+        }
+    }
+
+recdone:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+    set_current_state(TASK_RUNNING);
+    remove_wait_queue(&nvstream->wait,&waita);
+#else
+    finish_wait(&nvstream->wait,&waita);
+#endif
+    return received;
+}
+
+////////////////////////////////////////////////////////////////////////
+//  Function that drain remaining buffered data
+////////////////////////////////////////////////////////////////////////
+static void drain_dac(Nvaudio_card *card, Nvaudio_wavedev *nvwavdev, int nonblock)
+{
+    int status = 0;
+    unsigned long xferorig = 0;
+    unsigned long flags = 0;
+    mem_buf_t *mb = NULL;
+    Nvaudio_stream  *nvstream = NULL;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+    DECLARE_WAITQUEUE(wait,current);
+#else
+    DEFINE_WAIT(wait);
+#endif
+
+    //printk("Nvsound: DRAIN_DAC GET CALLED \n");
+    nvstream      = &(nvwavdev->playback_stream);
+    if(!nvstream) return;
+    mb = &(nvstream->buf[nvstream->fill_index]);
+    
+    if (nvstream->mapped) {
+        return;
+    }
+    
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+    add_wait_queue(&nvstream->wait,&wait);
+#endif
+    while (nvstream->total_played < nvstream->total_sent) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+        set_current_state(TASK_INTERRUPTIBLE);
+#else
+        prepare_to_wait(&nvstream->wait,&wait,TASK_INTERRUPTIBLE);
+#endif
+        if (!mb->in_use && mb->count) {
+            mb->in_use=TRUE;
+            xferorig = mb->xfer;
+            mb->xfer=0;
+            spin_lock_irqsave(&card->play_lock,flags);
+            //printk("Nvsound: DRAIN_DAC pass down the buffer \n");
+            status = Nv_passdown(nvstream->wavestream, mb->page, mb->count,nvstream->fill_index,TRUE);
+            if(status) {
+                mb->in_use = FALSE;
+                mb->xfer   = xferorig; 
+            }
+            spin_unlock_irqrestore(&card->play_lock,flags);
+        }else{
+            break;  
+        }
+
+        if (!nvstream->enable) {
+            //printk("Nvsound: DRAIN_DAC enable the stream \n");
+            spin_lock_irqsave(&card->play_lock, flags);
+            Nv_start(nvstream->wavestream);
+            nvstream->enable = TRUE;
+            spin_unlock_irqrestore(&card->play_lock, flags);
+        }
+        if(nonblock)
+            break;
+        //interruptible_sleep_on_timeout(&nvstream->wait,10);
+        schedule_timeout(10);
+        if (signal_pending(current)) {
+            break;
+        }
+        continue;
+    }
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+    set_current_state(TASK_RUNNING);
+    remove_wait_queue(&nvstream->wait,&wait);
+#else
+    finish_wait(&nvstream->wait,&wait);
+#endif
+
+    //printk("Nvsound: DRAIN_DAC left \n");
+}
+
+/////////////////////////////////////////////////////////////////////////
+//  Funtion to verify for ac3 data.
+//  This check the first few data for ac3 signature. 
+////////////////////////////////////////////////////////////////////////
+/*static int  Nvaudio_verifyac3(Nvaudio_stream  *nvstream,const char *buffer, size_t count)
+{
+    unsigned short ac3data[0x40];
+    int ac3size = 0, i = 0;
+    ac3size = sizeof(short) * 0x40;
+    memset(ac3data, 0, ac3size);
+    
+    if(count < ac3size) return 0;
+    copy_from_user(ac3data,buffer,ac3size);
+
+    for( i=0; i < 0x40; i++) {
+        if(ac3data[i] == 0xF872) {
+            i++;
+            if(ac3data[i] == 0x4E1F) {
+                nvstream->fmt.wformat  = AFMT_AC3;
+                return 1;
+            }
+        }
+    }
+    return 0;
+}*/
+////////////////////////////////////////////////////////////////////////
+//  Function that passed the data from user to hw for playback.   
+//  in this loop, sent signifies the amount of data that is waiting
+//  to be dma to the soundcard.  
+//  it is drained by the dma machine and filled by this loop. 
+////////////////////////////////////////////////////////////////////////
+static ssize_t Nvaudio_write(struct file *file, const char *buffer, size_t count, loff_t *ppos)
+{
+    size_t xfer =0, sent = 0;
+    Nvaudio_wavedev *nvwavdev = NULL;
+    Nvaudio_stream  *nvstream = NULL;
+    unsigned long flags = 0;
+    Nvaudio_card *card = (Nvaudio_card *)file->private_data;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+    DECLARE_WAITQUEUE(waitb,current);
+#else
+    DEFINE_WAIT(waitb);
+#endif
+
+    if(!count)
+        return 0;
+
+    nvwavdev = Nvfind_wave_device(card,file);
+    if(!nvwavdev) {
+        printk("Nvsound: Unable to find any wave device \n");
+        return -ENXIO;
+    }
+
+    nvstream = &nvwavdev->playback_stream;
+    /*if((nvstream->verifyac3 == 0) && (card->ac3_in_use == 0)) {
+        nvstream->verifyac3 = 1;
+        if(Nvaudio_verifyac3(nvstream,buffer,count)) {
+            printk("Nvsound: VERIFIED AS AC3 STREAM \n");
+            Nvfree_reopenStream(nvwavdev,file);
+        }
+    }*/
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,8)
+    if( ppos != &file->f_pos)
+        return -ESPIPE;
+#endif
+
+    if(nvstream->mapped)
+        return -ENXIO;
+    
+    if (!access_ok(VERIFY_READ, buffer, count))
+        return -EFAULT;
+
+    //printk("Nvsound: newstream %p  buffer %x size %d \n",stream, buffer,count);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+    add_wait_queue(&nvstream->wait,&waitb);
+#endif
+    while(sent < count) {
+        //copy as much as we caninto the dma buffers
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+        set_current_state(TASK_INTERRUPTIBLE);
+#else
+        prepare_to_wait(&nvstream->wait,&waitb,TASK_INTERRUPTIBLE);
+#endif
+        xfer = Nvfill_mem(card,nvstream,buffer+sent,(count-sent));
+        sent += xfer;
+        nvstream->total_sent += xfer;
+        
+        if(nvstream->pre_roll) { // stream not started app will call the start
+            if(sent < count){
+                sent = (sent)? (ssize_t) sent : -EAGAIN;
+                goto dacdone;
+            }else {
+                break;
+            }
+        }
+        if(nvstream->enable) { // stream already started
+            if(sent < count) {
+                if(file->f_flags & O_NONBLOCK) {
+                    sent = (sent) ? (ssize_t)sent: -EAGAIN;    
+                    goto dacdone;
+                }
+                
+                //interruptible_sleep_on(&nvstream->wait);
+                schedule_timeout(15);
+                if(signal_pending(current)) {
+                    //printk("KILL THE APPS \n");
+                    sent = (sent)? (ssize_t)sent : -ERESTARTSYS;
+                    goto dacdone;
+                }
+                continue;
+            }
+            
+        } else {
+            // stream not started yet - start if enough data or DSP_SYNC will be sent to start
+            if(nvstream->total_sent >= (2 * nvstream->frag_size)) {
+                spin_lock_irqsave(&card->play_lock, flags);   
+                Nv_start((void*)nvstream->wavestream);
+                nvstream->enable = TRUE;
+                spin_unlock_irqrestore(&card->play_lock, flags);
+            }else {
+                if(sent < count){
+                    sent= (sent)? (ssize_t) sent : -EAGAIN;
+                }
+            }
+
+        }
+    }
+
+dacdone:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+    set_current_state(TASK_RUNNING);
+    remove_wait_queue(&nvstream->wait,&waitb);
+#else
+    finish_wait(&nvstream->wait,&waitb);
+#endif
+
+    return sent;
+}
+////////////////////////////////////////////////////////////////////////
+// Function to poll the hw status
+////////////////////////////////////////////////////////////////////////
+static unsigned int Nvaudio_poll(struct file *file, struct poll_table_struct *wait)
+{
+    unsigned int mask   = 0;
+    unsigned long flags = 0;
+    int i = 0;
+    Nvaudio_wavedev *nvwavdev = NULL;
+    Nvaudio_card *card   = (Nvaudio_card *)file->private_data;
+    //printk("Nvaudio: Nvaudio_poll \n");
+    nvwavdev = Nvfind_wave_device(card,file);
+    if(!nvwavdev) {
+        printk("Nvsound: Unable to find any wave device \n");
+        return -ENXIO;
+    }
+
+    if(file->f_mode& FMODE_WRITE) {
+        poll_wait(file,&nvwavdev->playback_stream.wait,wait);
+    }
+
+    if(file->f_mode& FMODE_READ) {
+        poll_wait(file,&nvwavdev->record_stream.wait,wait);
+    }
+    
+    if (file->f_mode & FMODE_READ) {
+        spin_lock_irqsave(&card->rec_lock, flags);
+        for (i=0; i < nvwavdev->record_stream.num_frags; i++) {
+            if (nvwavdev->record_stream.buf[i].count > 0) {
+                mask |= POLLIN | POLLRDNORM;
+                break;
+            }
+        }
+        spin_unlock_irqrestore(&card->rec_lock, flags);
+    }
+
+    if (file->f_mode & FMODE_WRITE) {
+        spin_lock_irqsave(&card->play_lock, flags);
+        for (i=0; i < nvwavdev->playback_stream.num_frags; i++) {
+            if (nvwavdev->playback_stream.buf[i].count < nvwavdev->playback_stream.frag_size) {
+                mask |= POLLOUT | POLLWRNORM;
+                break;
+            }
+        }
+        spin_unlock_irqrestore(&card->play_lock, flags);
+    }
+    
+    return mask;
+}
+
+////////////////////////////////////////////////////////////////////////
+// Function to do mmap ioctls
+////////////////////////////////////////////////////////////////////////
+static int Nvaudio_mmap(struct file *file, struct vm_area_struct *vma)
+{
+    Nvaudio_wavedev *nvwavdev = NULL;
+    Nvaudio_stream  *nvstream = NULL;
+    unsigned long    size = 0, *phyArray = 0;
+    int pagecount = 0, pages = 0;
+    Nvaudio_card * card = file->private_data;
+    
+    //printk("Nvsound: Nvaudio_mmap \n");
+
+    nvwavdev = Nvfind_wave_device(card,file);
+    if(!nvwavdev) {
+        printk("Nvsound: Unable to find any wave device \n");
+        return -ENXIO;
+    }
+
+    size = vma->vm_end - vma->vm_start;
+
+    //
+    // check whether it is from our private allocation 
+    //
+    if(Nv_IsMmValid()){
+        //printk("Nvsound: mmap([0x%p-0x%p] off=0x%lx)\n",vma->vm_start,vma->vm_end,
+        //  NV_VMA_OFFSET(vma));
+        pagecount = size >> PAGE_SHIFT;
+        pages     = pagecount;
+
+        if(Nv_FindMmEntry((void *)NV_VMA_OFFSET(vma), (void**) &phyArray,pagecount)) {
+            // find in the list - remap it based on page count
+            unsigned long start = 0, phyAddr = 0;
+            start = vma->vm_start;
+#if defined (__x86_64__)
+            phyAddr = NV_VMA_OFFSET(vma);
+#endif
+            while(pagecount--) {
+#if defined (__i386__)              
+                if(phyArray)
+                    phyAddr = *phyArray;
+                
+                if(phyAddr == 0) return -EINVAL;
+#endif
+                if (NV_REMAP_PAGE_RANGE(start, phyAddr, PAGE_SIZE, vma->vm_page_prot)) {
+                    return -EAGAIN;
+                }
+                start   += PAGE_SIZE;
+#if defined (__x86_64__)
+                 phyAddr += PAGE_SIZE;  // using this as we did contiguous memory allocation
+#else
+                phyArray++;
+#endif
+            }   
+            // prevent the swapper from swapping it out
+            // mark the memory i/o so the buffers aren't dumped on core dumps
+            vma->vm_flags |= (VM_IO | VM_LOCKED);
+            vma->vm_file = file;
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 10))
+            if (vma->vm_flags & VM_LOCKED)
+                current->mm->locked_vm += pages;
+#endif
+
+            return 0;
+        }
+    }
+
+    // recheck this how important is this
+    if(vma->vm_pgoff != 0)
+        return -EINVAL;
+
+    lock_kernel();
+    
+    if (vma->vm_flags & VM_WRITE) {
+        nvstream = &nvwavdev->playback_stream;
+        if (!nvstream->wavestream || nvstream->enable || nvstream->mapped) {
+            unlock_kernel();
+            return -EINVAL;
+        }
+        if (size > (PAGE_SIZE << nvstream->buf_order)) {
+            unlock_kernel();
+            return -EINVAL;
+        }
+        if (NV_REMAP_PAGE_RANGE(vma->vm_start, virt_to_phys(nvstream->vir_dmabuf), size, vma->vm_page_prot)) {
+            unlock_kernel();
+            return -EAGAIN;
+        }
+        nvstream->mapped = TRUE;
+        unlock_kernel();  /* so we don't map twice if someone opens rw */
+        return 0;
+    }
+
+    if (vma->vm_flags & VM_READ) {
+        nvstream = &nvwavdev->record_stream;
+        if (!nvstream->wavestream || nvstream->enable || nvstream->mapped) {
+            unlock_kernel();
+            return -EINVAL;
+        }
+        if (size > (PAGE_SIZE << nvstream->buf_order)) {
+            unlock_kernel();
+            return -EINVAL;
+        }
+        if (NV_REMAP_PAGE_RANGE(vma->vm_start, virt_to_phys(nvstream->vir_dmabuf), size, vma->vm_page_prot)) {
+            unlock_kernel();
+            return -EAGAIN;
+        }
+        nvstream->mapped = TRUE;
+    }
+    unlock_kernel();
+    return 0;
+}
+
+////////////////////////////////////////////////////////////////////////
+// Function to do fill the memory appropriately for recording data
+////////////////////////////////////////////////////////////////////////
+static unsigned long Nvget_mem(Nvaudio_card *card, Nvaudio_stream *nvstream, char *mem, unsigned long size)
+{
+    unsigned long flags    = 0;
+    unsigned long received = 0;
+    unsigned long count    = 0, AmountToCopy = 0;
+    int status = 0, i=0;
+    mem_buf_t *mb          = NULL;
+#if (ENABLE_MONO)
+    u16*  buffloc          = NULL;
+    u16 left = 0 , right = 0;
+#endif
+    // if not enabled yet add all the buffer to the stream
+    if(!nvstream->enable) {
+        spin_lock_irqsave(&card->rec_lock,flags);
+        for(i=0; i<nvstream->num_frags; i++) {
+            nvstream->buf[i].count  = nvstream->frag_size;
+            nvstream->buf[i].in_use = TRUE;
+            status = Nv_passdown((void*)nvstream->wavestream,nvstream->buf[i].page,nvstream->buf[i].count,i,FALSE);
+            if(status) { // no more space to fill
+                nvstream->buf[i].count  = 0;
+                nvstream->buf[i].in_use = FALSE;
+                break;
+            }
+        }
+        spin_unlock_irqrestore(&card->rec_lock,flags);
+        return 0;
+    }
+    
+    AmountToCopy = size;
+    while((received < size) && (!nvstream->buf[nvstream->drain_index].in_use)) {
+        mb = (mem_buf_t *) &nvstream->buf[nvstream->drain_index]; 
+        count = AmountToCopy < (nvstream->frag_size - mb->count) ? AmountToCopy : nvstream->frag_size - mb->count;
+        
+        if(nvstream->Channels > 1) {
+            if(copy_to_user(mem,(u8*)mb->page + mb->count ,count)) {
+                break;
+            }
+            mb->count += count;
+            AmountToCopy -= count;
+        }
+#if (ENABLE_MONO)
+        else {
+            count = count >> 1;
+            buffloc = (u16 *)mb->page + (mb->count / 2) ;
+            for(i = 0; i < (count/2) ; i++) {
+                left  = *buffloc++;
+                mb->count += 2;
+                right = *buffloc++;
+                mb->count += 2;
+                if(copy_to_user(mem,(void*)&left,sizeof(u16))) {
+                    status = 1;
+                    break;
+                }
+                mem      += sizeof(u16);
+                received += sizeof(u16);
+                
+            }
+            if(status) break;
+            AmountToCopy = ((size - received) << 1);
+        }
+#endif
+        // once the buffer is copied add the buffer back if possible
+        if (mb->count >= nvstream->frag_size) {
+            spin_lock_irqsave(&card->rec_lock,flags);
+            status = Nv_passdown(nvstream->wavestream,nvstream->buf[nvstream->drain_index].page,nvstream->frag_size,nvstream->drain_index,FALSE);
+            spin_unlock_irqrestore(&card->rec_lock,flags);
+            if(status == 0) {
+                nvstream->buf[nvstream->drain_index].count  = nvstream->frag_size;
+                nvstream->buf[nvstream->drain_index].xfer   = 0;
+                nvstream->buf[nvstream->drain_index].in_use = TRUE;
+                nvstream->drain_index = (nvstream->drain_index + 1) % nvstream->num_frags;
+            }
+        }
+
+        if(nvstream->Channels > 1) {
+            received += count;
+            mem      += count;
+        }
+    }
+    return received;
+}
+
+////////////////////////////////////////////////////////////////////////
+// Function to do fill the memory appropriately for playback data
+////////////////////////////////////////////////////////////////////////
+static unsigned long Nvfill_mem(Nvaudio_card *card, Nvaudio_stream *nvstream, const char *mem, unsigned long size)
+{
+    unsigned long flags = 0;
+    unsigned long sent = 0;
+    unsigned long count;
+    int status = 0;
+    mem_buf_t *mb = (mem_buf_t *) &nvstream->buf[nvstream->fill_index];
+    while ((size > 0) && !mb->in_use) {
+        count = size < (nvstream->frag_size - mb->count) ? size : nvstream->frag_size - mb->count;
+        if(copy_from_user((u8 *)mb->page + mb->count, mem, count))
+            break;
+        mb->count += count;
+        // Send buffer to the dma engine if full.
+        if (mb->count >= nvstream->frag_size) {
+            spin_lock_irqsave(&card->play_lock, flags);
+            status  = Nv_passdown((void*)nvstream->wavestream,mb->page,mb->count,nvstream->fill_index,FALSE);
+            if(status) {
+                // unable to fill it now
+                spin_unlock_irqrestore(&card->play_lock, flags);
+                mb->count -= count;
+                return sent;
+            }
+            spin_unlock_irqrestore(&card->play_lock, flags);
+            mb->in_use = TRUE;
+            mb->xfer   = 0;
+            nvstream->fill_index = (nvstream->fill_index + 1) % nvstream->num_frags;
+            mb = (mem_buf_t *)&nvstream->buf[nvstream->fill_index];
+        }
+        size  -= count;
+        sent  += count;
+        mem   += count;
+    }
+    return sent;
+}
+#if(PRINT_IOCTL)
+////////////////////////////////////////////////////////////////////////
+// Function to print which ioctl get called
+////////////////////////////////////////////////////////////////////////
+static void Nvprint_ioctl(unsigned int cmd, unsigned long arg)
+{
+    unsigned int args = 0;
+    get_user(args, (int *)arg);
+    switch(cmd){
+        case OSS_GETVERSION:
+            printk("Nvsound: OSS_GETVERSION  \n");
+            break;
+        case SNDCTL_DSP_RESET:    
+            printk("Nvsound: SNDCTL_DSP_RESET  \n");
+            break;
+        case SNDCTL_DSP_SYNC:
+            printk("Nvsound: SNDCTL_DSP_SYNC  \n");
+            break;
+        case SNDCTL_DSP_SPEED: /* set smaple rate */
+            printk("Nvsound: SNDCTL_DSP_SPEED with Arg %d\n", args);
+            break;
+        case SNDCTL_DSP_STEREO: 
+            printk("Nvsound: SNDCTL_DSP_STEREO with Arg %d\n", args);
+            break;
+        case SNDCTL_DSP_GETBLKSIZE:
+            printk("Nvsound: SNDCTL_DSP_GETBLKSIZE  \n");
+            break;
+        case SNDCTL_DSP_GETFMTS: 
+            printk("Nvsound: SNDCTL_DSP_GETFMTS  \n");
+            break;    
+        case SNDCTL_DSP_SETFMT: 
+            printk("Nvsound: SNDCTL_DSP_SETFMT with Arg %d\n", args);
+            break;
+        case SNDCTL_DSP_CHANNELS:
+            printk("Nvsound: SNDCTL_DSP_CHANNELS with Arg %d\n", args);
+            break;
+        case SNDCTL_DSP_POST:
+            printk("Nvsound: SNDCTL_DSP_POST  \n");
+            break;
+        case SNDCTL_DSP_SUBDIVIDE:
+            printk("Nvsound: SNDCTL_DSP_SUBDIVIDE with Arg %d\n", args);
+            break;
+        case SNDCTL_DSP_SETFRAGMENT:
+            printk("Nvsound: SNDCTL_DSP_SETFRAGMENT with Arg %d\n", args);
+            break;
+        case SNDCTL_DSP_GETOSPACE:
+            printk("Nvsound: SNDCTL_DSP_GETOSPACE  \n");
+            break;
+        case SNDCTL_DSP_GETOPTR:
+            printk("Nvsound: SNDCTL_DSP_GETOPTR  \n");
+            break;
+        case SNDCTL_DSP_GETISPACE:
+            printk("Nvsound: SNDCTL_DSP_GETISPACE  \n");
+            break;
+        case SNDCTL_DSP_GETIPTR:
+            printk("Nvsound: SNDCTL_DSP_GETIPTR  \n");
+            break;
+        case SNDCTL_DSP_NONBLOCK:
+            printk("Nvsound: SNDCTL_DSP_NONBLOCK \n");
+            break;
+        case SNDCTL_DSP_GETCAPS:
+            printk("Nvsound: SNDCTL_DSP_GETCAPS  \n");
+            break;
+        case SNDCTL_DSP_GETTRIGGER:
+            printk("Nvsound: SNDCTL_DSP_GETTRIGGER \n");
+            break;
+        case SNDCTL_DSP_SETTRIGGER:
+            printk("Nvsound: SNDCTL_DSP_SETTRIGGER with Arg %d\n", args);
+            break;
+        case SNDCTL_DSP_SETDUPLEX:
+            printk("Nvsound: SNDCTL_DSP_SETDUPLEX  \n");
+            break;
+        case SNDCTL_DSP_GETODELAY:
+            printk("Nvsound: SNDCTL_DSP_GETODELAY  \n");
+            break;
+        case SOUND_PCM_READ_RATE:
+            printk("Nvsound: SOUND_PCM_READ_RATE  \n");
+            break;
+        case SOUND_PCM_READ_CHANNELS:
+            printk("Nvsound: SOUND_PCM_READ_CHANNELS \n");
+            break;
+        case SOUND_PCM_READ_BITS:
+            printk("Nvsound: SOUND_PCM_READ_BITS  \n");
+            break;
+        case SNDCTL_DSP_SETSPDIF: 
+            printk("Nvsound: SNDCTL_DSP_SETSPDIF  \n");
+            break;
+        case SNDCTL_DSP_GETSPDIF: 
+            printk("Nvsound: SNDCTL_DSP_GETSPDIF \n");
+            break;
+        case SNDCTL_DSP_GETCHANNELMASK:
+            printk("Nvsound: SNDCTL_DSP_GETCHANNELMASK \n");
+            break;
+        case SNDCTL_DSP_BIND_CHANNEL:
+            printk("Nvsound: SNDCTL_DSP_BIND_CHANNEL \n");
+            break;
+        default:       
+            printk("Nvsound: DEFAULT \n");
+    }
+
+}
+#endif
+
+////////////////////////////////////////////////////////////////////////
+// OSS ioctls are supported in this function
+////////////////////////////////////////////////////////////////////////
+static int Nvaudio_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+    int val = 0, i = 0, status = 0;
+    unsigned long flags = 0;
+    audio_buf_info abinfo;
+    int nfrags =0, fragsize =0;
+    count_info     cinfo;
+    Nvaudio_stream* nvstream = NULL;
+    Nvaudio_wavedev* nvwavdev = NULL;
+    Nvaudio_card *card  = (Nvaudio_card *)file->private_data;
+#if(PRINT_IOCTL)
+    Nvprint_ioctl(cmd,arg);
+#endif
+
+    nvwavdev = Nvfind_wave_device(card,file);
+    if(!nvwavdev) {
+        printk("Nvsound: Unable to find any wave device \n");
+        return -ENXIO;
+    }
+
+    switch(cmd){
+        case OSS_GETVERSION:
+            return put_user(SOUND_VERSION, (int *)arg);
+ 
+        case SNDCTL_DSP_RESET:    
+        {
+            Nvstop_wave(card,&(nvwavdev->playback_stream),PLAY_STREAM);
+            Nvstop_wave(card,&(nvwavdev->record_stream),REC_STREAM);
+            return 0;
+        }    
+
+        case SNDCTL_DSP_SYNC:
+        {
+            if(file->f_flags & O_NONBLOCK)
+                return 0;
+            if(nvwavdev->playback_stream.wavestream) {
+                drain_dac(card,nvwavdev,(file->f_flags & O_NONBLOCK));
+                Nvstop_wave(card,&(nvwavdev->playback_stream),PLAY_STREAM);
+            }
+            if(nvwavdev->record_stream.wavestream) {
+                Nvstop_wave(card,&(nvwavdev->record_stream),REC_STREAM);
+            }
+            return 0;
+        }
+
+        case SNDCTL_DSP_SPEED: /* set sample rate */
+            if (get_user(val, (int *)arg))
+                return -EFAULT;
+            
+            if(file->f_mode & FMODE_READ){
+                nvwavdev->record_stream.fmt.dwSampleRate   = val;
+                nvstream = &nvwavdev->record_stream;
+                if(nvstream->wavestream) {
+                    status = Nv_SetFormat((void*)nvstream->wavestream,&nvstream->fmt,SETSAMPLERATE);
+                    if(status) {
+                        printk("Nvsound: Unable to change the Record SampleRate %d, set back to 48000 \n",val);
+                        if(!(file->f_mode & FMODE_WRITE)) val = DEFAULT_SAMPLERATE; 
+                        nvwavdev->record_stream.fmt.dwSampleRate   = DEFAULT_SAMPLERATE;
+                    }
+                }
+            }
+
+            if(file->f_mode & FMODE_WRITE) {
+                nvwavdev->playback_stream.fmt.dwSampleRate = val;
+                nvstream = &nvwavdev->playback_stream;
+                status = Nv_SetFormat((void*)nvstream->wavestream,&nvstream->fmt,SETSAMPLERATE);
+                if(status) {
+                    printk("Nvsound: Unable to change the Playback SampleRate %d, set back to 48000 \n",val);
+                    val = DEFAULT_SAMPLERATE; 
+                    nvwavdev->playback_stream.fmt.dwSampleRate = DEFAULT_SAMPLERATE;
+                }
+            }
+            
+            return put_user(val, (int *)arg);
+
+        case SNDCTL_DSP_STEREO: /* set stereo or mono channel */
+            if (get_user(val, (int *) arg))
+                return -EFAULT;
+            if(file->f_mode & FMODE_WRITE){
+                nvstream = &nvwavdev->playback_stream;
+                nvstream->fmt.wChannels = (val ? 2 : 1);
+                status = Nv_SetFormat((void*)nvstream->wavestream,&nvstream->fmt,SETCHANNELS);
+                if(status){
+                    printk("Nvsound: Unable to set Mono, set back to Stereo \n");
+                    nvstream->fmt.wChannels = 2;
+                    val = 1 ; // set back to stereo
+                }
+            }
+            if(file->f_mode & FMODE_READ) {
+#if (ENABLE_MONO)
+                if(val == 0) nvwavdev->record_stream.Channels = 1;
+#endif
+            }
+            return put_user(val, (int *)arg);
+
+        case SNDCTL_DSP_GETBLKSIZE:
+            val = nvwavdev->playback_stream.frag_size;
+#if(PRINT_IOCTL)
+            printk(" Get BlockSize %d \n", val);
+#endif
+            return put_user(val,(int *)arg);
+
+        case SNDCTL_DSP_GETFMTS: /* Returns a mask of supported sample format*/
+        {
+            if(file->f_mode & FMODE_READ){
+                val = AFMT_S16_LE;
+            }
+            if(file->f_mode & FMODE_WRITE){
+                val = AFMT_S16_LE | AFMT_U8 | AFMT_AC3;
+            }
+
+            if((file->f_mode & FMODE_READ) && (file->f_mode & FMODE_WRITE)) {
+                val = AFMT_S16_LE;
+            }
+#if(PRINT_IOCTL)
+            printk(" Get Format as %d \n", val);
+#endif
+            return put_user(val, (int *) arg);
+
+        }
+
+        case SNDCTL_DSP_SETFMT: /* Select sample format */
+        {
+            if(get_user(val,(int *)arg))
+                return -EFAULT;
+            if(val != AFMT_QUERY) {
+                
+                if(file->f_mode & FMODE_READ){
+                    if(!(file->f_mode & FMODE_WRITE)) val = AFMT_S16_LE;
+                }
+                if(file->f_mode & FMODE_WRITE){
+                    if( (card->ac3_in_use) && (val == AFMT_AC3)) {
+                        // reset the value as AFMT_S16_LE
+                        val = AFMT_S16_LE;
+                    }else {
+                        // HACK ADDED FOR SPDIF - First verify the opened stream is of AFMT_AC3 format
+                        // If NOT KILL the opened stream and open a new stream with SpdifOut 
+                        if(nvwavdev->playback_stream.wavestream) {
+                            nvstream = &nvwavdev->playback_stream;
+                            if( val == AFMT_AC3) {
+                                if(nvstream->fmt.wformat != AFMT_AC3) {
+                                    nvstream->fmt.wformat = val;                            
+                                    Nvfree_reopenStream(nvwavdev,file);
+                                    nvstream->verifyac3 = 1;
+                                    nvstream->fmt.wBitsPerSample = 16;
+                                }
+                            }
+                            else if( val == AFMT_S16_LE) {
+                                nvstream->fmt.wBitsPerSample = 16;
+                            }
+                            else if ( val == AFMT_U8) {
+                                nvstream->fmt.wBitsPerSample = 8;
+                            }
+                            nvstream->fmt.wformat = val;
+                            //printk("Nvsound: Set format as %x \n", val);
+                            Nv_SetFormat((void*)nvstream->wavestream,&nvstream->fmt,SETFORMAT);
+                        }
+                    }
+                }
+            }
+            return put_user(val,(int*)arg);
+        }
+
+        case SNDCTL_DSP_CHANNELS:
+        {
+            if(get_user(val,(int *)arg))
+                return -EFAULT;
+            if(file->f_mode & FMODE_READ){
+#if(ENABLE_MONO)
+                nvstream = &nvwavdev->record_stream;
+                if(val == 1) nvstream->Channels = val;  
+#endif
+            }
+            if(file->f_mode & FMODE_WRITE){
+                if(nvwavdev->playback_stream.wavestream) {
+                        nvstream = &nvwavdev->playback_stream;
+                        nvstream->fmt.wChannels = val;
+                        spin_lock_irqsave(&card->play_lock,flags);
+                        status = Nv_SetFormat((void*)nvstream->wavestream,&nvstream->fmt,SETCHANNELS);
+                        spin_unlock_irqrestore(&card->play_lock,flags);
+                        if(status){
+                            printk("Nvsound: Unable to change the Channel, set back to Stereo \n");
+                            val = 2 ; // set back to stereo
+                            nvstream->fmt.wChannels = val;
+                        }
+                    }
+            }
+            return put_user(val,(int*) arg);
+        }
+ 
+        case SNDCTL_DSP_POST:
+        {
+            if(!nvwavdev->playback_stream.wavestream)
+                return -EINVAL;
+            drain_dac(card,nvwavdev,(file->f_flags & O_NONBLOCK));
+            Nvstop_wave(card,&(nvwavdev->playback_stream),PLAY_STREAM);
+            return 0;
+        }
+
+        case SNDCTL_DSP_SUBDIVIDE:
+            if (get_user(val, (int *)arg))
+                return -EFAULT; 
+            return 0;
+
+        case SNDCTL_DSP_SETFRAGMENT:
+            if (get_user(val, (int *) arg))
+                return -EFAULT;
+            nfrags   = (val >> 16) & 0xffff;
+            fragsize = 1 << (val & 0xffff);
+            //printk(" nfrags %d fragsize %d \n", nfrags,fragsize);
+            nvstream = &nvwavdev->playback_stream;
+            if(nvstream) {
+                if(fragsize >  nvstream->frag_size){
+                    nfrags = nfrags * (fragsize / nvstream->frag_size);
+                    fragsize = nvstream->frag_size;
+                }else if(fragsize < (nvstream->frag_size / 4)){
+                    nfrags = nfrags *  4;
+                    fragsize = nvstream->frag_size / 4;
+                }
+
+                if(nfrags > NVBUFFER_FRAGMENTS) nfrags = NVBUFFER_FRAGMENTS;
+
+                val = fragsize * nfrags;
+                while (val > (NVMAX_FRAGSIZE * NVMAX_FRAGS)){
+                    nfrags = nfrags >> 1;
+                    val = fragsize * nfrags;
+                }
+            
+                nvstream->num_frags = nfrags;
+                nvstream->frag_size = fragsize;
+            }
+
+            nvstream = &nvwavdev->record_stream;
+            if(nvstream) {
+                nvstream->num_frags = nfrags;
+                nvstream->frag_size = fragsize;
+            }
+            //printk(" nfrags %d fragsize %d \n", nfrags,fragsize);
+            status = 0;
+            return status;
+
+        case SNDCTL_DSP_GETOSPACE:
+        {
+            if(!nvwavdev->playback_stream.wavestream)
+                return -EINVAL;
+            nvstream = &nvwavdev->playback_stream;
+            abinfo.fragsize   = nvstream->frag_size;
+            abinfo.fragstotal = nvstream->num_frags;
+            abinfo.bytes      = 0;
+            abinfo.fragments  = 0;
+            spin_lock_irqsave(&card->play_lock,flags);
+            for(i = 0; i < nvstream->num_frags; i++) {
+                if(!nvstream->buf[i].in_use) {
+                    abinfo.bytes += (nvstream->frag_size - nvstream->buf[i].count);
+                    if (nvstream->buf[i].count == 0) 
+                        ++abinfo.fragments;
+                } 
+            }
+            spin_unlock_irqrestore(&card->play_lock,flags);
+#if(PRINT_IOCTL)
+            printk(" Bytes  %d frags %d \n", abinfo.bytes, abinfo.fragments);
+#endif
+            return copy_to_user((void*)arg,&abinfo,sizeof(abinfo)) ? -EFAULT: 0;    
+        }
+
+        case SNDCTL_DSP_GETOPTR:
+        {
+            nvstream = &nvwavdev->playback_stream;
+            cinfo.blocks = nvstream->total_played / nvstream->frag_size;
+            cinfo.bytes  = nvstream->total_played;
+            cinfo.ptr    = (nvstream->frag_size * nvstream->drain_index) + nvstream->buf[nvstream->drain_index].xfer;
+#if(PRINT_IOCTL)
+            printk(" Current ptr  %d totalplayed %d blocks avail %d \n", cinfo.ptr,cinfo.bytes,cinfo.blocks);
+#endif
+            return copy_to_user((void*)arg, &cinfo, sizeof(cinfo));
+        }
+
+        case SNDCTL_DSP_GETISPACE:
+        {
+            if(!nvwavdev->record_stream.wavestream)
+                return -EINVAL;
+            nvstream = &nvwavdev->record_stream;
+            abinfo.fragsize   = nvstream->frag_size;
+            abinfo.fragstotal = nvstream->num_frags;
+            abinfo.bytes      = 0;
+            abinfo.fragments  = 0;
+            spin_lock_irqsave(&card->rec_lock,flags);
+            for(i=0; i < nvstream->num_frags; i++) {
+                if(!nvstream->buf[i].in_use){
+                    abinfo.bytes += (nvstream->frag_size - nvstream->buf[i].count);
+                    if(nvstream->buf[i].count == 0)
+                        ++abinfo.fragments;
+                }
+            }
+            spin_unlock_irqrestore(&card->rec_lock,flags);
+            return copy_to_user((void *)arg, &abinfo, sizeof(abinfo)) ? -EFAULT : 0;
+        }    
+
+        case SNDCTL_DSP_GETIPTR:
+        {
+            nvstream     = &nvwavdev->record_stream;
+            cinfo.bytes  = nvstream->total_played;
+            cinfo.blocks = nvstream->total_played / nvstream->frag_size;
+            cinfo.ptr    = (nvstream->frag_size * nvstream->fill_index) + nvstream->buf[nvstream->fill_index].xfer;
+#if(PRINT_IOCTL)
+            printk(" Current ptr  %d totalplayed %d blocks avail %d \n", cinfo.ptr,cinfo.bytes,cinfo.blocks);
+#endif
+            return copy_to_user((void*)arg, &cinfo, sizeof(cinfo));
+        }
+
+        case SNDCTL_DSP_NONBLOCK:
+            file->f_flags |= O_NONBLOCK;
+            return 0;
+
+        case SNDCTL_DSP_GETCAPS:
+            return put_user(DSP_CAP_DUPLEX| DSP_CAP_REALTIME |DSP_CAP_TRIGGER |DSP_CAP_MMAP |DSP_CAP_MULTI, (int *)arg);
+
+        case SNDCTL_DSP_GETTRIGGER:
+        {
+            val = 0;
+            if(nvwavdev->record_stream.wavestream && !nvwavdev->record_stream.pre_roll)
+                val |= PCM_ENABLE_INPUT;
+            if(nvwavdev->playback_stream.wavestream && !nvwavdev->playback_stream.pre_roll)
+                val |= PCM_ENABLE_OUTPUT;
+            return put_user(val, (int *)arg);
+        }
+
+        case SNDCTL_DSP_SETTRIGGER:
+        {
+            if(get_user(val,(int *)arg)){
+                return -EFAULT;
+            }
+
+            if (file->f_mode & FMODE_READ) {
+                nvstream = &nvwavdev->record_stream;
+                if(val & PCM_ENABLE_INPUT) {
+                    if (nvstream->wavestream && (nvstream->pre_roll || nvstream->mapped)) {
+                        spin_lock_irqsave(&card->rec_lock, flags);
+                        
+                        for (i = 0; i < nvstream->num_frags; i++){
+                            nvstream->buf[i].count = nvstream->frag_size;
+                            nvstream->buf[i].in_use = TRUE;
+                            memset(nvstream->buf[i].page, (nvstream->fmt.wformat == AFMT_S16_LE) ? 0 : 0x80, nvstream->frag_size);
+                            Nv_passdown(nvstream->wavestream, nvstream->buf[i].page, nvstream->frag_size,i,FALSE);
+                        }
+
+                        if (nvstream->mapped && !nvstream->mapped_setup) {
+                            nvstream->mapped_setup = TRUE;
+                        }
+
+                        Nv_start(nvstream->wavestream);
+                        nvstream->enable   = TRUE;
+                        nvstream->pre_roll = FALSE;
+                        spin_unlock_irqrestore(&card->rec_lock, flags);
+                    }
+                } else if (nvstream->wavestream) {
+                    if(nvstream->mapped && nvstream->mapped_setup) {
+                        spin_lock_irqsave(&card->rec_lock, flags);
+                        Nv_stop(nvstream->wavestream);
+                        spin_unlock_irqrestore(&card->rec_lock, flags);
+                    }else{
+                        Nvstop_wave(card,nvstream,REC_STREAM);
+                    }
+                    nvstream->pre_roll = TRUE;
+                }
+            }
+
+            if(file->f_mode & FMODE_WRITE) {
+                nvstream = &nvwavdev->playback_stream;
+                if(val & PCM_ENABLE_OUTPUT) {
+                    if(nvstream->wavestream && (nvstream->mapped || nvstream->pre_roll)){
+                        spin_lock_irqsave(&card->play_lock,flags);
+                        for (i = 0; i < nvstream->num_frags; i++) {
+                            nvstream->buf[i].count = nvstream->frag_size;
+                            nvstream->buf[i].in_use = TRUE;
+                            memset(nvstream->buf[i].page, (nvstream->fmt.wformat == AFMT_S16_LE) ? 0 : 0x80, nvstream->frag_size);
+                            Nv_passdown(nvstream->wavestream, nvstream->buf[i].page, nvstream->frag_size,i,FALSE);
+                        }
+                        if(nvstream->mapped && !nvstream->mapped_setup) {
+                            nvstream->mapped_setup = TRUE;
+                        }
+                        Nv_start(nvstream->wavestream);
+                        nvstream->enable   = TRUE;
+                        nvstream->pre_roll = FALSE;
+                        spin_unlock_irqrestore(&card->play_lock,flags);
+                    }
+                }else if(nvstream->wavestream) {
+                    if(nvstream->mapped && nvstream->mapped_setup){
+                        spin_lock_irqsave(&card->play_lock,flags);
+                        Nv_stop(nvstream->wavestream);
+                        spin_unlock_irqrestore(&card->play_lock,flags);
+                    }else{
+                        Nvstop_wave(card,nvstream,PLAY_STREAM);
+                    }
+                    nvstream->pre_roll = TRUE;
+                }
+            }
+           
+            return 0;
+        }
+
+        case SNDCTL_DSP_SETDUPLEX:
+             return 0;
+
+        case SNDCTL_DSP_GETODELAY:
+        {
+            val = 0;
+            nvstream = &nvwavdev->playback_stream;
+            for(i=0; i < nvstream->num_frags; i++) {
+                if(nvstream->buf[i].in_use)
+                val += (nvstream->buf[i].count - nvstream->buf[i].xfer);
+            }
+
+            #if(PRINT_IOCTL)
+                printk(" DelayBytes  %d \n", val);
+            #endif
+
+            return put_user(val,(int *)arg);
+        }
+
+        case SOUND_PCM_READ_RATE:
+        {
+            val = 0;
+            if (file->f_mode & FMODE_READ) {
+                nvstream = &nvwavdev->record_stream;
+                val = nvstream->fmt.dwSampleRate;
+                
+            }
+            if(file->f_mode & FMODE_WRITE) {
+                nvstream = &nvwavdev->playback_stream;
+                val = nvstream->fmt.dwSampleRate;
+            }
+        
+            return put_user(val,(int *) arg);   
+        }
+        case SOUND_PCM_READ_BITS:
+        {
+            val = 0;
+            if (file->f_mode & FMODE_READ) {
+                nvstream = &nvwavdev->record_stream;
+                val = nvstream->fmt.wBitsPerSample;
+                
+            }
+            if(file->f_mode & FMODE_WRITE) {
+                nvstream = &nvwavdev->playback_stream;
+                val = nvstream->fmt.wBitsPerSample;
+            }
+        
+            return put_user(val,(int *) arg);   
+            
+        }
+        case SOUND_PCM_READ_CHANNELS:
+        {
+            val = 0;
+            if (file->f_mode & FMODE_READ) {
+                nvstream = &nvwavdev->record_stream;
+                val = nvstream->fmt.wChannels;
+                
+            }
+            if(file->f_mode & FMODE_WRITE) {
+                nvstream = &nvwavdev->playback_stream;
+                val = nvstream->fmt.wChannels;
+            }
+        
+            return put_user(val,(int *) arg);   
+
+        }
+       case SNDCTL_DSP_GETCHANNELMASK:
+       case SNDCTL_DSP_BIND_CHANNEL:
+            return -EINVAL;
+        default:      
+            return Nvaudio_private_ioctl(card,file,cmd,arg);
+    }
+    return 0;
+}
+
+////////////////////////////////////////////////////////////////////////
+// OSS /dev/mixer file operation methods 
+////////////////////////////////////////////////////////////////////////
+static int Nvaudio_open_mixdev(struct inode *inode, struct file *file)
+{
+    int minor = MINOR(inode->i_rdev);
+    // as we support only one card now
+    Nvaudio_card *card = devs;
+    //printk("Nvsound:  Nvaudio_open_mixdev %p \n", card);
+    if(!card) return -ENODEV;
+    if(card->dev_mixer == minor){
+        file->private_data = devs;
+        return 0;
+    }
+    return -ENODEV;
+}
+
+static struct file_operations Nv_mixer_fops = {
+    owner:      THIS_MODULE,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,9)
+    llseek:     no_llseek,
+#endif
+    ioctl:      Nvaudio_ioctl_mixdev,
+    open:       Nvaudio_open_mixdev,
+};
+
+////////////////////////////////////////////////////////////////////////
+// Function to support the open calls
+// Suppose to call multiple playback streams
+// Support only one record stream
+// Fullduplex supported.
+// If all stream are open just schedule a wait or fail the call
+////////////////////////////////////////////////////////////////////////
+static int Nvaudio_open(struct inode *inode, struct file *file)
+{
+    int status = 0;
+    int minor_num = DEVMINOR(inode->i_rdev);
+    int dev_type  = DEVICE_TYPE(minor_num);
+
+    //printk("Open device with file %p \n", (void*)file);
+    // need to add a function to find the device when we support multiple cards
+    Nvaudio_card *card = devs;
+    if(card) {
+        status = Nvadd_wave_device(card, file, dev_type);
+        if(status) {
+            printk("Nvsound: Unable to allocate the wave device \n");
+            return status;
+        }
+    }
+    file->private_data = (void *) card;
+    return 0;
+}
+
+////////////////////////////////////////////////////////////////////////
+// Function to stop the running wave
+////////////////////////////////////////////////////////////////////////
+static void Nvstop_wave(Nvaudio_card *card, Nvaudio_stream *nvstream, int type)
+{
+    int i;
+    unsigned long flags = 0;
+    if (nvstream->wavestream) {
+        if(type == PLAY_STREAM)
+            spin_lock_irqsave(&card->play_lock, flags);
+        else
+            spin_lock_irqsave(&card->rec_lock, flags);
+        Nv_stop(nvstream->wavestream);
+
+        if(type == PLAY_STREAM)
+            spin_unlock_irqrestore(&card->play_lock, flags);
+        else
+            spin_unlock_irqrestore(&card->rec_lock, flags);
+
+    }
+    nvstream->enable = nvstream->pre_roll = FALSE;
+    nvstream->total_played = nvstream->total_sent = 0;
+    nvstream->fill_index = nvstream->drain_index = 0;
+    //nvstream->verifyac3  = 0;
+    nvstream->lastposition = 0;
+    for (i = 0; i < nvstream->num_frags; i++) {
+        nvstream->buf[i].count = nvstream->buf[i].xfer = 0;
+        nvstream->buf[i].in_use = FALSE;
+    }
+}
+////////////////////////////////////////////////////////////////////////
+// Function to support the release/close calls
+////////////////////////////////////////////////////////////////////////
+static int Nvaudio_release(struct inode *inode, struct file *file)
+{
+    Nvaudio_wavedev *nvwavdev = NULL;
+    Nvaudio_card *card   = (Nvaudio_card *)file->private_data;
+    //printk("Nvsound: Nvaudio_release with fileptr %p \n", file);
+
+    nvwavdev = Nvfind_wave_device(card,file);
+    if(!nvwavdev) {
+        printk("Nvsound: Unable to find any wave device \n");
+        return -ENXIO;
+    }
+    lock_kernel();
+    
+    if(nvwavdev->playback_stream.wavestream){
+        drain_dac(card,nvwavdev,(file->f_flags & O_NONBLOCK));
+    }
+    if(nvwavdev->record_stream.wavestream){
+       card->rec_in_use = FALSE; 
+    }
+
+    //if(nvwavdev->playback_stream.fmt.wformat == AFMT_AC3) card->ac3_in_use = 0;
+    Nvstop_wave(card,&(nvwavdev->playback_stream),PLAY_STREAM);
+    Nvstop_wave(card,&(nvwavdev->record_stream),REC_STREAM);
+    Nv_VerifyFilePtr((void*)file);
+    Nvremove_wave_device(card,nvwavdev);
+    unlock_kernel();
+    return 0;
+}
+
+////////////////////////////////////////////////////////////////////////
+// Function to support the release/close calls
+////////////////////////////////////////////////////////////////////////
+static int Nvfree_reopenStream(Nvaudio_wavedev *nvwavdev, struct file *file)
+{
+    Nvaudio_stream* nvstream = NULL;
+    unsigned long flags = 0;
+    int status = 0;
+    Nvaudio_card *card  = (Nvaudio_card *)file->private_data;
+    nvstream = &nvwavdev->playback_stream;
+    if(nvstream->wavestream){
+        drain_dac(card,nvwavdev,(file->f_flags & O_NONBLOCK));
+    }
+    Nvstop_wave(card,nvstream,PLAY_STREAM);
+    //
+    // Remove the opened Stream 
+    //
+    if (nvstream->wavestream) {
+        spin_lock_irqsave(&card->play_lock, flags);
+        Nv_FreeNewstream(nvstream->wavestream);
+        spin_unlock_irqrestore(&card->play_lock, flags);
+    }
+    //
+    // Open a new stream with Spdif out pin
+    //
+    status = Nv_CreateNewstream(&(nvstream->fmt),NVDIRPLAY,&(nvstream->wavestream),card->hwbase->apupresent);
+    if(status) {
+        printk("Nvsound: Unable to Create a NewStream for apu \n");
+        Nvfree_wave_device(card,nvwavdev);
+        return -ENOMEM;
+    }
+    card->ac3_in_use = 1;
+    return status;
+}
+
+static struct file_operations Nvaudio_fops = {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,9)
+    llseek:     no_llseek,
+#endif
+    owner:      THIS_MODULE,
+    read:       Nvaudio_read,
+    write:      Nvaudio_write,
+    poll:       Nvaudio_poll,
+    ioctl:      Nvaudio_ioctl,
+    mmap:       Nvaudio_mmap,
+    open:       Nvaudio_open,
+    release:    Nvaudio_release,
+};
+
+////////////////////////////////////////////////////////////////////////
+// NvRelease_Resources
+////////////////////////////////////////////////////////////////////////
+static void NvRelease_Resources(Nvaudio_card *card)
+{
+    if(!card || !(card->hwbase)) { 
+        devs = 0;
+        return;
+    }
+
+    // release region & irq of apu portion 
+    if(card->hwbase->apuirq){
+        free_irq(card->hwbase->apuirq,card);
+        card->hwbase->apuirq = 0;
+    }
+    // release region & irq of apu portion 
+    if(card->hwbase->aciirq){
+        free_irq(card->hwbase->aciirq,card);
+        card->hwbase->aciirq = 0;
+    }
+
+    if(card->hwbase->ac97base) {
+        release_region (card->hwbase->ac97base, card->hwbase->ac97length);
+        card->hwbase->ac97base = 0;
+        card->hwbase->ac97length = 0;
+    }
+
+    // release the region for aci 
+    if(card->hwbase->acibase) {
+        release_region (card->hwbase->acibase, card->hwbase->acilength);
+        card->hwbase->acibase = 0;
+        card->hwbase->acilength = 0;
+        pci_set_drvdata(card->hwbase->pAci_dev,NULL);
+    }
+    
+    if(card->hwbase->apubase) {
+        release_mem_region(card->hwbase->apubase,card->hwbase->apulength);
+        pci_set_drvdata(card->hwbase->pApu_dev, NULL);
+        card->hwbase->apubase =  0;
+        card->hwbase->apulength = 0;
+    }
+
+        // if /dev/mixer is registered - unregister it 
+    if(card->dev_mixer >  -1 ) {
+        unregister_sound_mixer(card->dev_mixer);
+        printk("KERN_INFO Nvsound: Release DEV MIXER %d \n", card->dev_mixer);
+        card->dev_mixer = -1;
+    }
+    
+    if(card->dev_audio > -1 ){
+        unregister_sound_dsp(card->dev_audio);
+        card->dev_audio = -1;
+    }
+
+    // disable the pci devices - as 2.6.10 shows warning
+    /*if(card->hwbase){
+        if(card->hwbase->pAci_dev) {
+            pci_disable_device(card->hwbase->pAci_dev);
+            card->hwbase->pAci_dev = NULL;
+        }
+        if(card->hwbase->pApu_dev) {
+            pci_disable_device(card->hwbase->pApu_dev);
+            card->hwbase->pApu_dev = NULL;
+        }
+    }*/
+
+
+    if(card->hwbase){
+        kfree(card->hwbase);
+        card->hwbase = 0;
+    }
+
+    // since we support only one device set devs
+
+    memset(card, 0, sizeof(Nvaudio_card));
+
+    kfree(card);
+
+    devs = NULL;
+}
+
+////////////////////////////////////////////////////////////////////////
+// Nvaudio Apu Init call
+////////////////////////////////////////////////////////////////////////
+static int Nvaudio_apuinit( PNVHWBASE pHwBase)
+{
+    if(Nv_CreateApuExec(pHwBase) == 0) return 1;
+    else return -1;
+}
+
+////////////////////////////////////////////////////////////////////////
+// probe module function
+////////////////////////////////////////////////////////////////////////
+static int __devinit Nvaudio_probe(struct pci_dev *ppci_dev, const struct pci_device_id *pci_id)
+{
+    int ret = 0;
+    
+    if(pci_set_dma_mask(ppci_dev,NVAUDIO_DMA_MASK)) {
+        printk(KERN_ERR "Nvsound: Nvaudio doesnot support PCI busmaster \n ");
+        return -ENODEV;
+    }
+    if(pci_enable_device(ppci_dev))
+        return -EIO;
+
+    pci_set_master(ppci_dev);
+
+    /* Handle the apu and aci separately */
+    if((ppci_dev->device == PCI_DEVICE_ID_NVIDIA_MCP2_CONTROLLER) ||
+       (ppci_dev->device == PCI_DEVICE_ID_NVIDIA_MCP1_CONTROLLER)
+    ) {
+        
+        if(devs == NULL) {
+            if((devs = kmalloc(sizeof(Nvaudio_card),GFP_KERNEL)) == NULL) {
+                printk(KERN_ERR "Nvsound:  apu: out of Memory \n");
+                return -ENOMEM;
+            }
+
+            memset(devs, 0, sizeof(Nvaudio_card));
+            
+            if((devs->hwbase = kmalloc(sizeof(NVHWBASE),GFP_KERNEL)) == NULL) {
+                printk(KERN_ERR "Nvsound:  apu hwbase: out of Memory \n");
+                return -ENOMEM;
+            }
+            memset(devs->hwbase, 0, sizeof(NVHWBASE));
+            spin_lock_init(&devs->play_lock);
+            spin_lock_init(&devs->rec_lock);
+            spin_lock_init(&devs->list_lock);
+        }
+        
+        devs->hwbase->apupresent = 1;
+        devs->hwbase->apubase    = pci_resource_start(ppci_dev,0);
+        devs->hwbase->apulength  = pci_resource_len(ppci_dev,0);
+        devs->hwbase->apuirq     = ppci_dev->irq;
+        devs->hwbase->pApu_dev   = (void *)ppci_dev;
+        
+        devs->pci_id     = ppci_dev->device;
+        devs->drivertype = APU_DRIVER;
+
+        if(request_mem_region(devs->hwbase->apubase, devs->hwbase->apulength, card_names[pci_id->driver_data]) == NULL) {
+            printk(KERN_ERR "Nvsound:  APU Region In Use \n");
+            ret = -EBUSY;
+            NvRelease_Resources(devs);
+            return ret;
+        }
+
+        printk(KERN_INFO "Nvsound:  %s Mem 0x%04lx and IRQ %x\n",
+           card_names[pci_id->driver_data], devs->hwbase->apubase,devs->hwbase->apuirq);
+
+        
+        if(request_irq(devs->hwbase->apuirq,&Nvapu_interrupt, SA_SHIRQ, card_names[pci_id->driver_data], devs)) {
+            printk(KERN_ERR "Nvsound:  IRQ in use \n");
+            ret = -EBUSY;
+            NvRelease_Resources(devs);
+            return ret;
+        }
+
+        pci_set_drvdata(ppci_dev, devs);
+
+    }else{
+        if(devs == NULL) {
+            if((devs = kmalloc(sizeof(Nvaudio_card),GFP_KERNEL)) == NULL) {
+                printk(KERN_ERR "Nvsound:  out of Memory \n");
+                return -ENOMEM;
+            }
+            memset(devs, 0, sizeof(Nvaudio_card));
+            
+            if((devs->hwbase = kmalloc(sizeof(NVHWBASE),GFP_KERNEL)) == NULL) {
+                printk(KERN_ERR "Nvsound: aci hwbase: out of Memory \n");
+                return -ENOMEM;
+            }
+            memset(devs->hwbase, 0, sizeof(NVHWBASE));
+            spin_lock_init(&devs->play_lock);
+            spin_lock_init(&devs->rec_lock);
+            spin_lock_init(&devs->list_lock);
+        }
+        devs->hwbase->acipresent = 1;
+        devs->hwbase->ac97base   = pci_resource_start(ppci_dev,0);
+        devs->hwbase->ac97length = pci_resource_len(ppci_dev,0);
+        devs->hwbase->acibase    = pci_resource_start(ppci_dev,1);        
+        devs->hwbase->acilength  = pci_resource_len(ppci_dev,1);
+        devs->hwbase->aciirq     = ppci_dev->irq;
+        devs->hwbase->pAci_dev   = (void *)ppci_dev;
+        
+        devs->pci_id     = ppci_dev->device;
+        devs->drivertype = ACI_DRIVER;
+               
+        if(request_region(devs->hwbase->acibase, devs->hwbase->acilength, card_names[pci_id->driver_data]) == NULL) {
+            printk(KERN_ERR "Nvsound: ACI Region In Use \n");
+            ret = -EBUSY;
+            NvRelease_Resources(devs);
+            return ret;
+        }
+        
+        if(request_region(devs->hwbase->ac97base, devs->hwbase->ac97length, card_names[pci_id->driver_data]) == NULL) {
+            printk(KERN_ERR "Nvsound: AC97 Region In Use \n");
+            ret = -EBUSY;
+            NvRelease_Resources(devs);
+            return ret;
+        }
+
+        printk(KERN_INFO "Nvsound: %s aci 0x%04lx and ac97 0x%04lx, IRQ %x\n",
+           card_names[pci_id->driver_data], devs->hwbase->acibase, devs->hwbase->ac97base,
+           devs->hwbase->aciirq);
+
+        // register /dev/mixer
+        devs->dev_mixer = -1;
+        if ((devs->dev_mixer = register_sound_mixer(&Nv_mixer_fops, -1)) < 0) {
+            printk(KERN_ERR "Nvsound: couldn't register mixer!\n");
+            NvRelease_Resources(devs);
+            ret = -EBUSY;
+            return ret;
+        }
+
+        devs->dev_audio = -1;
+        // register the /dev/dsp 
+        if((devs->dev_audio = register_sound_dsp(&Nvaudio_fops, -1)) < 0 ) {
+            NvRelease_Resources(devs);
+            ret = -EBUSY;
+            return ret;
+        }
+
+        if(devs->hwbase->apupresent)
+            pci_set_drvdata(ppci_dev,NULL);
+        else
+            pci_set_drvdata(ppci_dev,devs);
+
+        //Initialize APU and register the Mixer /dev/mixer 
+        // If we support multiple card then we need to keep track of the apuinit pointer too
+        // Set the vapu_enable bit
+        devs->hwbase->vapuinit = vapu_enable;
+        if( Nvaudio_apuinit(devs->hwbase) <= 0) {
+            NvRelease_Resources(devs);
+            ret = -ENOMEM;
+            return ret;
+        }
+
+        // ISR should be register after the initialization
+        if(request_irq(devs->hwbase->aciirq,&Nvaci_interrupt, SA_SHIRQ, card_names[pci_id->driver_data], devs)) {
+            printk(KERN_ERR "Nvsound: IRQ in use \n");
+            NvRelease_Resources(devs);
+            ret = -EBUSY;
+            return ret;
+        }
+       
+        printk(KERN_INFO "Nvsound: DEV MIXER %d DEV AUDIO %d \n", devs->dev_mixer, devs->dev_audio);
+    }
+    return 0;
+}
+
+////////////////////////////////////////////////////////////////////////
+// remove function
+////////////////////////////////////////////////////////////////////////
+static void __devexit Nvaudio_remove(struct pci_dev *ppci_dev)
+{
+    Nvaudio_card *card = pci_get_drvdata(ppci_dev);
+    printk(KERN_INFO "Nvsound: Audio getting removed %p \n",card);
+    if(card) {
+        Nv_FreeApuExec();
+        NvRelease_Resources(card);
+        devs = NULL;
+    }
+}
+
+MODULE_PARM(vapu_enable, "i");
+#define NVAUDIO_MODULE_NAME "nforce_audio"
+static struct pci_driver Nvaudio_pci_driver = {
+    name: NVAUDIO_MODULE_NAME,
+    id_table: Nvaudio_pci_tbl,
+    probe:    Nvaudio_probe,
+    remove: __devexit_p(Nvaudio_remove),
+};
+
+////////////////////////////////////////////////////////////////////////
+// init module function
+////////////////////////////////////////////////////////////////////////
+static int __init Nvaudio_init_module (void)
+{
+    int ret = 0;
+    printk(KERN_INFO "Nvsound: Nvidia Audio Init Module, " __TIME__ " " __DATE__ " version %s \n",
+           DRIVERVER);
+    ret = pci_module_init(&Nvaudio_pci_driver);
+    return ret;
+}
+
+////////////////////////////////////////////////////////////////////////
+// Module clean function
+////////////////////////////////////////////////////////////////////////
+static void __exit Nvaudio_cleanup_module (void)
+{
+    pci_unregister_driver(&Nvaudio_pci_driver);
+}
+
+module_init(Nvaudio_init_module);
+module_exit(Nvaudio_cleanup_module);
